#include "options.h"
#include "file.h"
#include "controls.h"
#include "keyboard.h"
#include "audio.h"
#include "music.h"
#include "windowManager.h"
#include "replayOptions.h"
#include "controlOptionsMenu.h"
#include "videoOptionsMenu.h"
#include <adlmidi.h>

static int16_t m_gameStyle;         // 0 = PC, 1 = Amiga

#include "options.mnu.h"

enum SoundEnabledState { kUnspecified, kOn, kOff, } static m_soundState;
static bool m_noIntro;
static bool m_noReels;
static bool m_noLoadPause;
static int m_bankNo;

using OptionalControls = std::pair<bool, Controls>;
using OptionalJoypadGuid = std::pair<bool, std::string>;

OptionalControls m_pl1Controls;
OptionalControls m_pl2Controls;

OptionalJoypadGuid m_pl1Joypad;
OptionalJoypadGuid m_pl2Joypad;

static constexpr char kIniFilename[] = "swos.ini";
static constexpr char kStandardSection[] = "standardOptions";

static const std::array<Option<int16_t>, 9> kStandardOptions = {
    "gameLength",  &swos.g_gameLength, 0, 3, 0,
    "autoReplays",  &swos.g_autoReplays, 0, 1, 0,
    "menuMusic",  &swos.g_menuMusic, 0, 1, 1,
    "autoSaveHighlights",  &swos.g_autoSaveHighlights, 0, 1, 1,
    "allPlayerTeamsEqual", &swos.g_allPlayerTeamsEqual, 0, 1, 0,
    "pitchType", &swos.g_pitchType, -2, 6, 4,
    "chairmanScenes", &swos.g_chairmanScenes, 0, 1, 1,
    "showBigLetterS", &swos.g_spinBigS, 0, 1, 0,
    "gameStyle", &m_gameStyle, 0, 1, 0,
};

#ifdef __ANDROID__
static SI_Error loadIniFile(CSimpleIni& ini, const std::string& path);
static SI_Error saveIniFile(const CSimpleIni& ini, const std::string& path);
#endif

static SI_Error safeSaveIniFile(CSimpleIni& ini, const std::string& path);
static void setDefaultOptions();

void loadOptions()
{
    auto path = pathInRootDir(kIniFilename);
    logInfo("Loading options from %s", path.c_str());

    CSimpleIniA ini(true);

#ifdef __ANDROID__
    auto errorCode = loadIniFile(ini, path);
#else
    auto errorCode = ini.LoadFile(path.c_str());
#endif

    if (errorCode >= 0) {
        loadOptions(ini, kStandardOptions, kStandardSection);

        loadControlOptions(ini);

        loadAudioOptions(ini);
        loadVideoOptions(ini);
        loadReplayOptions(ini);
    } else {
        logWarn("Error loading options, error code: %d", errorCode);
        setDefaultOptions();
    }
}

void saveOptions()
{
    auto path = pathInRootDir(kIniFilename);
    logInfo("Saving options to %s...", path.c_str());

    CSimpleIniA ini(true);
    ini.SetValue(kStandardSection, nullptr, nullptr, "; Automatically generated by SWOS\n"
        "; Careful when editing the file -- the changes might get lost!\n" );

    saveOptions(ini, kStandardOptions, kStandardSection);
    saveControlOptions(ini);

    saveAudioOptions(ini);
    saveVideoOptions(ini);
    saveReplayOptions(ini);

    auto errorCode = safeSaveIniFile(ini, path);

    if (errorCode < 0) {
        beep();
        logWarn("Failed to save options, error code: %d", errorCode);
    }
}

static void setDefaultOptions()
{
    swos.g_spinBigS = 0;
    swos.g_autoReplays = 1;
    swos.g_menuMusic = 1;
    swos.g_autoSaveHighlights = 1;
    swos.g_pitchType = -1;
    swos.g_chairmanScenes = 0;
    swos.g_soundOff = 0;
    swos.g_musicOff = 0;
    swos.g_commentary = 1;
}

static SI_Error safeSaveIniFile(CSimpleIni& ini, const std::string& path)
{
    const auto& tmpFile = path + ".tmp";
#ifdef __ANDROID__
    auto errorCode = saveIniFile(ini, tmpFile.c_str());
#else
    auto errorCode = ini.SaveFile(tmpFile.c_str());
#endif
    if (errorCode != SI_OK)
        return errorCode;

    return renameFile(tmpFile.c_str(), path.c_str()) ? SI_OK : SI_FILE;
}

#ifdef __ANDROID__
static SI_Error loadIniFile(CSimpleIni& ini, const std::string& path)
{
    auto f = openFile(path.c_str(), "r");
    if (!f)
        return SI_FILE;

    auto size = SDL_RWsize(f);
    if (size < 0) {
        SDL_RWclose(f);
        return SI_FILE;
    }

    char iniBuf[6 * 1024];
    void *buf = iniBuf;
    size_t numRead = 0;

    if (size > sizeof(iniBuf)) {
        buf = SDL_malloc(size);
        if (!buf) {
            SDL_RWclose(f);
            return SI_NOMEM;
        }
    }
    numRead = SDL_RWread(f, buf, size, 1);

    if (!numRead) {
        SDL_RWclose(f);
        return SI_FILE;
    }

    auto result = ini.LoadData(iniBuf, size);

    if (buf != iniBuf)
        SDL_free(buf);

    return result;
}

class RWopsWriter : public CSimpleIni::OutputWriter {
public:
    RWopsWriter(const std::string& path) {
        m_context = openFile(path.c_str(), "w");
    }
    ~RWopsWriter() {
        if (m_context)
            SDL_RWclose(m_context);
    }
    void Write(const char *buf) override {
        if (m_context)
            SDL_RWwrite(m_context, buf, strlen(buf), 1);
    }
private:
    SDL_RWops *m_context = nullptr;
};

static SI_Error saveIniFile(const CSimpleIni& ini, const std::string& path)
{
    RWopsWriter writer(path);
    return ini.Save(writer, true);
}
#endif

template<typename LogFunction>
static void parseControls(LogFunction log, OptionalControls& controls, const char *str)
{
    char *endPtr;
    auto controlsIndex = strtol(str, &endPtr, 0);

    if (endPtr == str) {
        controls.first = true;

        if (strstr(str, "none") == str) {
            controls.second = kNone;
        } else if (strstr(str, "keyboard1") == str) {
            controls.second = kKeyboard1;
        } else if (strstr(str, "keyboard2") == str) {
            controls.second = kKeyboard2;
        } else if (strstr(str, "joystick") == str || strstr(str, "joypad")) {
            controls.second = kJoypad;
        } else {
            log("Unrecognized control name: "s + str);
            controls.first = false;
        }
    } else {
        if (controlsIndex >= 0 && controlsIndex < kNumControls) {
            controls.first = true;
            controls.second = static_cast<Controls>(controlsIndex);
        } else {
            auto max = std::to_string(static_cast<int>(kNumControls) - 1);
            log(std::to_string(controls.second) + " is not valid value for controls ([0.." + max + "] accepted)");
        }
    }
}

std::vector<LogItem> parseCommandLine(int argc, char **argv)
{
    std::vector<LogItem> commandLineWarnings;

    const char kSwosDir[] = "--swos-dir=";
    const char kSound[] = "--sound=";
    const char kNoIntro[] = "--no-intro";
    const char kNoReels[] = "--no-image-reels";
    const char kNoLoadPause[] = "--no-load-pause";
    const char kMaxBank[] = "--max-bank";
    const char kBankNum[] = "--bank-number=";
    const char kPl1Controls[] = "--pl1controls=";
    const char kPl2Controls[] = "--pl2controls=";
    const char kPl1Joypad[] = "--pl1joypad=";
    const char kPl2Joypad[] = "--pl2joypad=";

    auto log = [&commandLineWarnings](const std::string& str, LogCategory category = kWarning) {
        commandLineWarnings.emplace_back(category, str);
    };

    for (int i = 1; i < argc; i++) {
        if (strstr(argv[i], kSwosDir) == argv[i]) {
            setRootDir(argv[i] + sizeof(kSwosDir) - 1);
        } else if (strstr(argv[i], kSound) == argv[i]) {
            auto setting = argv[i] + sizeof(kSound) - 1;
            m_soundState = (tolower(setting[0]) != 'o' || tolower(setting[1]) != 'n') && setting[0] != '1' ? kOff : kOn;
        } else if (!strcmp(argv[i], kNoIntro)) {
            m_noIntro = true;
        } else if (!strcmp(argv[i], kNoReels)) {
            m_noReels = true;
        } else if (!strcmp(argv[i], kNoLoadPause)) {
            m_noLoadPause = true;
        } else if (!strcmp(argv[i], kMaxBank)) {
            log("Maximum bank number is " + std::to_string(adl_getBanksCount() - 1), kInfo);
        } else if (strstr(argv[i], kBankNum) == argv[i]) {
            auto bankNumStr = argv[i] + sizeof(kBankNum) - 1;
            auto bankNo = atoi(bankNumStr);
            auto maxBankNo = adl_getBanksCount() - 1;
            if (bankNo >= 0 && bankNo <= maxBankNo) {
                m_bankNo = bankNo;
            } else {
                auto warningText = "Invalid bank number " + std::to_string(bankNo) +
                    ", range is [0.." + std::to_string(maxBankNo) + "]";
                log(warningText);
            }
        } else if (strstr(argv[i], kPl1Controls) == argv[i] || strstr(argv[i], kPl2Controls)) {
            assert(argv[i][4] == '1' || argv[i][4] == '2');

            auto& controls = argv[i][4] == '1' ? m_pl1Controls : m_pl2Controls;
            auto controlsStr = argv[i] + sizeof(kPl1Controls) - 1;

            parseControls(log, controls, controlsStr);

            if (controls.first && controls.second == kNone && &controls == &m_pl1Controls) {
                controls.first = false;
                log("Player 1 can not have controls disabled");
            }
        } else if (strstr(argv[i], kPl1Joypad) == argv[i] || strstr(argv[i], kPl2Joypad) == argv[i]) {
            assert(argv[i][4] == '1' || argv[i][4] == '2');

            auto& joypad = argv[i][4] == '1' ? m_pl1Joypad : m_pl2Joypad;
            auto joypadStr = argv[i] + sizeof(kPl1Joypad) - 1;

            if (*joypadStr) {
                joypad.first = true;
                joypad.second = joypadStr;
            }
        } else {
            log("Unknown option ignored: "s + argv[i]);
        }
    }

    return commandLineWarnings;
}

void normalizeOptions()
{
    if (m_soundState != kUnspecified) {
        auto soundOff = m_soundState == kOff;
        swos.g_soundOff = soundOff;
        swos.g_musicOff = soundOff;
        swos.g_menuMusic = !swos.g_musicOff;
    }

    if (!keyboardPresent())
        unsetKeyboardControls();
}

bool disableIntro()
{
    return m_noIntro;
}

bool disableImageReels()
{
    return m_noReels;
}

bool doNotPauseLoadingScreen()
{
    return m_noLoadPause;
}

int midiBankNumber()
{
    return m_bankNo;
}

//
// options menu
//

void SWOS::OptionsMenuSelected()
{
    logInfo("Showing options menu...");

    showMenu(optionsMenu);

    logInfo("Leaving options menu");
    CommonMenuExit();
}

static void exitOptions()
{
    static int s_counter;

    if (swos.controlMask == kShortFireMask) {
        SetExitMenuFlag();
        saveOptions();
    } else if (swos.controlMask == (kShortFireMask | kDownMask) && ++s_counter == 15) {
        auto entry = getMenuEntry(OptionsMenu::Entries::secret);
        entry->show();
    }
}

static void doShowVideoOptionsMenu()
{
    showVideoOptionsMenu();
}

static void doShowAudioOptionsMenu()
{
    showAudioOptionsMenu();
}

static void doShowControlOptionsMenu()
{
    showControlOptionsMenu();
}

static void showGameplayOptions()
{
    showMenu(gameplayOptionsMenu);
}

static void changeGameStyle()
{
    logInfo("Game style changed to %s", m_gameStyle ? "AMIGA" : "PC");
    m_gameStyle = !m_gameStyle;
}

static void initGamePlayOptions()
{
    auto autoSaveReplaysEntry = getMenuEntry(GameplayOptionsMenu::autoSaveReplays);
    strcpy(autoSaveReplaysEntry->string(), getAutoSaveReplays() ? swos.aOn : swos.aOff);
}

static void toggleAutoSaveReplays()
{
    setAutoSaveReplays(!getAutoSaveReplays());
    initGamePlayOptions();
}
