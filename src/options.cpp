#include "options.h"
#include "file.h"
#include "controls.h"
#include "render.h"
#include "audio.h"
#include "music.h"
#include "controlOptionsMenu.h"
#include "options.mnu.h"
#include <adlmidi.h>

enum SoundEnabledState { kUnspecified, kOn, kOff, } static m_soundState;
static bool m_noIntro;
static bool m_noReels;
static int m_bankNo;

using OptionalControls = std::pair<bool, Controls>;
using OptionalJoypadGuid = std::pair<bool, std::string>;

OptionalControls m_pl1Controls;
OptionalControls m_pl2Controls;

OptionalJoypadGuid m_pl1Joypad;
OptionalJoypadGuid m_pl2Joypad;

static int16_t m_gameStyle;         // 0 = PC, 1 = Amiga

static constexpr char kIniFilename[] = "swos.ini";
static constexpr char kStandardSection[] = "standard-options";

static const std::array<Option<int16_t>, 9> kStandardOptions = {
    "gameLength",  &g_gameLength, 0, 3, 0,
    "autoReplays",  &g_autoReplays, 0, 1, 0,
    "menuMusic",  &g_menuMusic, 0, 1, 1,
    "autoSaveHighlights",  &g_autoSaveHighlights, 0, 1, 1,
    "allPlayerTeamsEqual", &g_allPlayerTeamsEqual, 0, 1, 0,
    "pitchType", &g_pitchType, -2, 6, 4,
    "chairmanScenes", &g_chairmanScenes, 0, 1, 1,
    "showBigLetterS", &g_spinBigS, 0, 1, 0,
    "gameStyle", &m_gameStyle, 0, 1, 0,
};

void loadOptions()
{
    logInfo("Loading options");

    CSimpleIniA ini(true);
    auto path = pathInRootDir(kIniFilename);

    auto errorCode = ini.LoadFile(path.c_str());
    if (errorCode >= 0) {
        loadOptions(ini, kStandardOptions, kStandardSection);

        loadControlOptions(ini);

        loadAudioOptions(ini);
        loadVideoOptions(ini);
    } else {
        logWarn("Error loading options, error code: %d", errorCode);
    }
}

void saveOptions()
{
    logInfo("Saving options...");

    CSimpleIniA ini(true);
    ini.SetValue(kStandardSection, nullptr, nullptr, "; Automatically generated by SWOS\n"
        "; Do not edit! All your changes will be lost\n" );

    saveOptions(ini, kStandardOptions, kStandardSection);
    saveControlOptions(ini);

    saveAudioOptions(ini);
    saveVideoOptions(ini);

    auto path = pathInRootDir(kIniFilename);
    auto errorCode = ini.SaveFile(path.c_str());

    if (errorCode < 0) {
        beep();
        logWarn("Failed to save options, error code: %d", errorCode);
    }
}

template<typename LogFunction>
static void parseControls(LogFunction log, OptionalControls& controls, const char *str)
{
    char *endPtr;
    auto controlsIndex = strtol(str, &endPtr, 0);

    if (endPtr == str) {
        controls.first = true;

        if (strstr(str, "none") == str) {
            controls.second = kNone;
        } else if (strstr(str, "keyboard1") == str) {
            controls.second = kKeyboard1;
        } else if (strstr(str, "keyboard2") == str) {
            controls.second = kKeyboard2;
        } else if (strstr(str, "joystick") == str || strstr(str, "joypad")) {
            controls.second = kJoypad;
        } else {
            log(std::string("Unrecognized control name: ") + str);
            controls.first = false;
        }
    } else {
        if (controlsIndex >= 0 && controlsIndex < kNumControls) {
            controls.first = true;
            controls.second = static_cast<Controls>(controlsIndex);
        } else {
            auto max = std::to_string(static_cast<int>(kNumControls) - 1);
            log(std::to_string(controls.second) + " is not valid value for controls ([0.." + max + "] accepted)");
        }
    }
}

std::vector<LogItem> parseCommandLine(int argc, char **argv)
{
    std::vector<LogItem> commandLineWarnings;

    const char kSwosDir[] = "--swos-dir=";
    const char kSound[] = "--sound=";
    const char kNoIntro[] = "--no-intro";
    const char kNoReels[] = "--no-image-reels";
    const char kMaxBank[] = "--max-bank";
    const char kBankNum[] = "--bank-number=";
    const char kPl1Controls[] = "--pl1controls=";
    const char kPl2Controls[] = "--pl2controls=";
    const char kPl1Joypad[] = "--pl1joypad=";
    const char kPl2Joypad[] = "--pl2joypad=";

    auto log = [&commandLineWarnings](const std::string& str, LogCategory category = kWarning) {
        commandLineWarnings.emplace_back(category, str);
    };

    for (int i = 1; i < argc; i++) {
        if (strstr(argv[i], kSwosDir) == argv[i]) {
            setRootDir(argv[i] + sizeof(kSwosDir) - 1);
        } else if (strstr(argv[i], kSound) == argv[i]) {
            auto setting = argv[i] + sizeof(kSound) - 1;
            m_soundState = (tolower(setting[0]) != 'o' || tolower(setting[1]) != 'n') && setting[0] != '1' ? kOff : kOn;
        } else if (!strcmp(argv[i], kNoIntro)) {
            m_noIntro = true;
        } else if (!strcmp(argv[i], kNoReels)) {
            m_noReels = true;
        } else if (!strcmp(argv[i], kMaxBank)) {
            log(std::string("Maximum bank number is ") + std::to_string(adl_getBanksCount() - 1), kInfo);
        } else if (strstr(argv[i], kBankNum) == argv[i]) {
            auto bankNumStr = argv[i] + sizeof(kBankNum) - 1;
            auto bankNo = atoi(bankNumStr);
            auto maxBankNo = adl_getBanksCount() - 1;
            if (bankNo >= 0 && bankNo <= maxBankNo) {
                m_bankNo = bankNo;
            } else {
                auto warningText = std::string("Invalid bank number ") + std::to_string(bankNo) +
                    ", range is [0.." + std::to_string(maxBankNo) + "]";
                log(warningText);
            }
        } else if (strstr(argv[i], kPl1Controls) == argv[i] || strstr(argv[i], kPl2Controls)) {
            assert(argv[i][4] == '1' || argv[i][4] == '2');

            auto& controls = argv[i][4] == '1' ? m_pl1Controls : m_pl2Controls;
            auto controlsStr = argv[i] + sizeof(kPl1Controls) - 1;

            parseControls(log, controls, controlsStr);

            if (controls.first && controls.second == kNone && &controls == &m_pl1Controls) {
                controls.first = false;
                log("Player 1 can not have controls disabled");
            }
        } else if (strstr(argv[i], kPl1Joypad) == argv[i] || strstr(argv[i], kPl2Joypad) == argv[i]) {
            assert(argv[i][4] == '1' || argv[i][4] == '2');

            auto& joypad = argv[i][4] == '1' ? m_pl1Joypad : m_pl2Joypad;
            auto joypadStr = argv[i] + sizeof(kPl1Joypad) - 1;

            if (*joypadStr) {
                joypad.first = true;
                joypad.second = joypadStr;
            }
        } else {
            log(std::string("Unknown option ignored: ") + argv[i]);
        }
    }

    return commandLineWarnings;
}

void normalizeOptions()
{
    if (m_soundState != kUnspecified) {
        auto soundOff = m_soundState == kOff;
        g_soundOff = soundOff;
        g_musicOff = soundOff;
        g_menuMusic = !g_musicOff;
    }

    normalizeInput();
}

bool disableIntro()
{
    return m_noIntro;
}

bool disableImageReels()
{
    return m_noReels;
}

int midiBankNumber()
{
    return m_bankNo;
}

//
// options menu
//

void SWOS::OptionsMenuSelected()
{
    logInfo("Showing options menu...");

    showMenu(optionsMenu);

    logInfo("Leaving options menu");
    CommonMenuExit();
}

void exitOptions()
{
    if (controlsStatus == 0x20) {
        SetExitMenuFlag();
        saveOptions();
    } else if (controlsStatus == 0x30 && ++showPrereleaseCounter == 15) {
        auto entry = getMenuEntry(OptionsMenu::Entries::secret);
        entry->show();
    }
}

void doShowVideoOptionsMenu()
{
    showVideoOptionsMenu();
}

void doShowAudioOptionsMenu()
{
    showAudioOptionsMenu();
}

void doShowControlOptionsMenu()
{
    showControlOptionsMenu();
}

void showGameplayOptions()
{
    showMenu(gameplayOptionsMenu);
}

void changeGameStyle()
{
    logInfo("Game style changed to %s", m_gameStyle ? "AMIGA" : "PC");
    m_gameStyle = !m_gameStyle;
}
