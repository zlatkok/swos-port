#include "SymbolFileParser.h"
#include "AmigaRegs.h"
#include "Util.h"

constexpr int kImportsCapacity = 3'000;
constexpr int kExportsCapacity = 7'500;
constexpr int kMaxExportEntries = 600;

static const char kHeader[] =
    "// " kAutoGeneratedWarningText "\n\n"
    "#pragma once\n\n"

    "#include \"swos.h\"\n\n"

    "#pragma pack(push, 1)\n"
    "// 68k register, 32-bit value, support for accessing as byte/word/dword and various casts\n"
    "struct Register\n{\n"
    "    Register(byte b) : data(b) {}\n"
    "    Register(word w) : data(w) {}\n"
    "    Register(dword d) : data(d) {}\n"
    "    Register(int i) : data(i) {}\n"
    "    Register(const char *p) : data(reinterpret_cast<dword>(p)) {}\n"
    "    template <typename T> Register(T t) { assign<T>(t); }\n"
    "    template <typename T> void assign(typename std::enable_if<std::is_convertible<T, dword>::value, T>::type t) {\n"
    "        data = static_cast<dword>(t);\n"
    "    }\n"
    "    template <typename T> void assign(typename std::enable_if<!std::is_convertible<T, dword>::value, T>::type t) {\n"
    "        data = reinterpret_cast<dword>(t);\n"
    "    }\n"
    "    word asWord() const { return static_cast<word>(data); }\n"
    "    int16_t asInt16() const { return static_cast<int16_t>(data); }\n"
    "    dword asDword() const { return static_cast<dword>(data); }\n"
    "    int asInt() const { return static_cast<int>(data); }\n"
    "    MenuEntry *asMenuEntry() { return reinterpret_cast<MenuEntry *>(data); }\n"
    "    template <typename T> typename std::enable_if<std::is_convertible<T, dword>::value, T>::type as() {\n"
    "         return static_cast<T>(data);\n"
    "    }\n"
    "    template <typename T> typename std::enable_if<!std::is_convertible<T, dword>::value, T>::type as() {\n"
    "        return reinterpret_cast<T>(data);\n"
    "    }\n"
    "    template <typename T> const T as() const { return reinterpret_cast<T>(data); }\n"
    "    char *asPtr() { return reinterpret_cast<char *>(data); }\n"
    "    const char *asPtr() const { return reinterpret_cast<char *>(data); }\n"
    "    template <typename T> operator T*() const { return reinterpret_cast<T *>(data); }\n"
    "    operator dword() const { return data; }\n"
    "    Register& operator+=(size_t n) { data += n; return *this; }\n"
    "    Register& operator++() { data++; return *this; }\n"
    "    Register operator++(int) { Register old(*this); data++; return old; }\n"
    "    dword data;\n"
    "};\n"
    "#pragma pack(pop)\n\n"

    "constexpr int k68kRegisterTotalSize = 15 * 4;\n\n"

    "struct MenuBase;\n\n"

    "extern \"C\" {\n"
    "    extern Register ";

SymbolFileParser::SymbolFileParser(const char *symbolFilePath, const char *headerFilePath)
    : m_path(symbolFilePath), m_headerPath(headerFilePath), m_imports(kImportsCapacity),
    m_exports(kExportsCapacity), m_importEntries(kImportsCapacity * 3 / 2)
{
    auto result = Util::loadFile(symbolFilePath, true);
    m_data.reset(result.first);
    m_dataSize = result.second;
    m_exportEntries.reserve(kMaxExportEntries);

    parseSymbolFile();

    addHookProcs();
    m_symbolTable.seal();

    // we won't need this any longer
    m_symbolLine.clear();
}

SymbolFileParser::SymbolFileParser(const SymbolFileParser& other)
    : m_path(other.m_path), m_headerPath(other.m_headerPath), m_exports(other.m_exports),
    m_imports(other.m_imports), m_exportEntries(other.m_exportEntries),
    m_importEntries(other.m_importEntries), m_symbolTable(other.m_symbolTable)
{
}

SymbolTable& SymbolFileParser::symbolTable()
{
    return m_symbolTable;
}

const SymbolTable & SymbolFileParser::symbolTable() const
{
    return m_symbolTable;
}

void SymbolFileParser::outputHeaderFile(const char *path)
{
    m_headerFile = fopen(path, "w");
    if (!m_headerFile)
        Util::exit("Could not open %s for write", EXIT_FAILURE, path);

    xfwrite(kHeader);

    output68kRegisters();
    outputExports();
    outputImports();

    fclose(m_headerFile);
}

const StringList& SymbolFileParser::exports() const
{
    return m_exports;
}

const StringList& SymbolFileParser::imports() const
{
    return m_imports;
}

void SymbolFileParser::output68kRegisters()
{
    for (int i = 0; i < kNumAmigaRegisters - 1; i++) {
        xfwrite(indexToAmigaRegister(i));
        xfwrite(", ");
    }

    xfwrite(indexToAmigaRegister(kNumAmigaRegisters - 1));
    xfwrite(";\n");
}

void SymbolFileParser::outputExports()
{
    for (const auto& exp : m_exportEntries) {
        xfwrite("    extern ");

        if (exp.function || exp.functionPointer)
            outputExportFunction(exp);
        else {
            outputExportVariable(exp);
        }

        xfwrite(";\n");
    }
}

void SymbolFileParser::outputImports()
{
    // put imports into namespace to avoid name clashes
    if (!m_imports.empty())
        xfwrite("\n    namespace SWOS {\n");

    for (const auto& imp : m_importEntries) {
        assert(imp.returnType() == kVoid || imp.returnType() == kInt);

        xfwrite("        extern ");

        if (imp.returnType() == kVoid)
            xfwrite("void ");
        else
            xfwrite("int ");

        xfwrite(imp.name());
        xfwrite("();\n");
    }

    if (!m_imports.empty())
        xfwrite("    }\n");

    xfwrite("}\n");
}

void SymbolFileParser::outputExportFunction(const ExportEntry& exp)
{
    assert(exp.function || exp.functionPointer);

    xfwrite("void ");

    if (exp.functionPointer)
        xfwrite("(*");

    if (!exp.prefix.empty())
        xfwrite(exp.prefix);
    xfwrite(exp.symbol);

    if (exp.functionPointer)
        xfwrite(")");

    xfwrite("()");
}

void SymbolFileParser::outputExportVariable(const ExportEntry& exp)
{
    assert(!exp.function && !exp.functionPointer);

    auto isPointer = exp.type.endsWith('*');
    auto needsParens = isPointer && exp.trailingArray;
    int charsToRemove = needsParens;

    if (exp.type.endsWith("(*)")) {
        isPointer = true;
        needsParens = true;
        charsToRemove = 3;
    }

    xfwrite(exp.type.substr(0, exp.type.length() - charsToRemove));

    if (!isPointer)
        xfwrite(" ");

    if (needsParens)
        xfwrite("(*");

    if (!exp.prefix.empty())
        xfwrite(exp.prefix);
    xfwrite(exp.symbol);

    if (needsParens)
        xfwrite(")");

    if (exp.trailingArray)
        xfwrite("[]");

    if (exp.array) {
        xfwrite("[");
        if (!exp.arraySize.empty())
            xfwrite(exp.arraySize);
        xfwrite("]");
    }
}

void SymbolFileParser::parseSymbolFile()
{
    assert(m_data && m_dataSize);

    auto p = m_data.get();
    auto sentinel = p + m_dataSize;

    const char *start;
    auto action = SymbolAction::kNone;

    while (true) {
        while (Util::isSpace(*p) && p < sentinel) {
            m_lineNo += *p == '\n';
            p++;
        }

        if (p >= sentinel) {
            break;
        } else if (*p == '#') {
            p = parseComment(p + 1);
            continue;
        } else if (*p == '@') {
            std::tie(start, p, action) = parseSectionName(p + 1);
        } else {
            if (action == kNone)
                error("section expected");

            start = p;
            while (!Util::isSpace(*p) && *p != '-' && *p != ',')
                p++;

            auto symStart = start;
            auto symEnd = p;

            if (action == kReplace || action == kInsertCall) {
                while (Util::isSpace(*p) && *p != '\n')
                    p++;

                if (*p != ',')
                    commaExpectedError();

                do {
                    p++;
                } while (Util::isSpace(*p) && *p != '\n');

                start = p;

                while (*p != '\n')
                    p++;

                if (p > start && p[-1] == '\r')
                    p--;
            } else {
                while (*p != '\n' && Util::isSpace(*p))
                    p++;

                if (*p == '-') {
                    do {
                        p++;
                    } while (Util::isSpace(*p));

                    start = p;
                    do {
                        p++;
                    } while (!Util::isSpace(*p));

                    if (p == start)
                        error("end of range missing");
                } else {
                    start = p;
                }
            }

            if (action == kRemove || action == kNull || action == kInsertCall) {
                if (action == kInsertCall) {
                    parseHookProcLine(symStart, symEnd, start, p);
                } else {
                    parseRemoveAndNullLine(action, symStart, symEnd, start, p);
                    ensureUniqueSymbol(symStart, symEnd, kGlobal, action);
                }
            } else {
                if (action != kReplace && action != kInsertCall && start != p)
                    error("ranges only supported for removing/nullifying procs/data items");

                auto ns = kGlobal;
                if (action == kSaveCppRegisters)
                    ns = kSaveRegs;
                else if (action == kOnEnter)
                    ns = kOnEnterNs;
                else if (action == kReplace)
                    ns = kReplaceNs;

                ensureUniqueSymbol(symStart, symEnd, ns, action);

                if (action == kExport || action == kImport) {
                    if (action == kExport) {
                        p = addExportEntry(symStart, symEnd);
                        m_exports.add(symStart, symEnd);
                    } else {
                        p = addImportEntry(symStart, symEnd);
                        m_imports.add(symStart, symEnd);
                        m_symbolTable.addSymbolAction(symStart, symEnd, kRemove | kRemoveSolo, nullptr, 0);
                    }
                } else if (action == kSaveCppRegisters || action == kOnEnter) {
                    m_symbolTable.addSymbolAction(symStart, symEnd, action);
                    if (action == kOnEnter) {
                        char buf[256];
                        auto len = symEnd - symStart;

                        memcpy(buf, symStart, len);
                        strcpy(buf + len, kOnEnterSuffix);

                        m_imports.add(buf, buf + len + sizeof(kOnEnterSuffix) - 1);
                        m_importEntries.emplace(String(buf, buf + len + sizeof(kOnEnterSuffix) - 1));
                    }
                } else if (action == kReplace) {
                    if (p == start)
                        error("missing replacement content");

                    m_symbolTable.addSymbolReplacement(symStart, symEnd, kReplace, start, p);
                }
            }

            while (*p != '\n' && Util::isSpace(*p))
                p++;

            if (*p != '\n')
                error("unexpected input encountered");
        }
    }
}

const char *SymbolFileParser::parseComment(const char *p)
{
    while (*p != '\n')
        p++;

    return p;
}

auto SymbolFileParser::parseSectionName(const char *p) const -> std::tuple<const char *, const char *, SymbolAction>
{
    auto start = p;

    while (!Util::isSpace(*p))
        p++;

    auto action = getSectionName(start, p);

    if (action == kNone)
        error(std::string("unknown directive: ") + std::string(p, start - p));

    return { start, p, action };
}

auto SymbolFileParser::getSectionName(const char *begin, const char *end) -> SymbolAction
{
    auto action = kNone;
    auto len = end - begin;

    if (len == 6) {
        if (!memcmp(begin, "remove", 6)) {
            action = kRemove;
        } else if (!memcmp(begin, "export", 6)) {
            action = kExport;
        } else if (!memcmp(begin, "import", 6)) {
            action = kImport;
        }
    } else if (len == 4) {
        if (!memcmp(begin, "null", 4))
            action = kNull;
    } else if (len == 7) {
        if (!memcmp(begin, "replace", 7))
            action = kReplace;
    } else if (len == 8) {
        if (!memcmp(begin, "on-enter", 8))
            action = kOnEnter;
    } else if (len == 9) {
        if (!memcmp(begin, "save-regs", 9))
            action = kSaveCppRegisters;
    } else if (len == 11) {
        if (!memcmp(begin, "insert-hook", 11))
            action = kInsertCall;
    }

    return action;
}

const char *SymbolFileParser::handlePotentialArray(const char *start, const char *p, ExportEntry& e)
{
    if (*p == '[') {
        auto typeStart = start;
        std::tie(start, p) = getNextToken(p + 1);

        std::string sizeStr = { start, p };
        e.arraySize = { start, p };

        if (sizeStr == "]") {
            if (e.array)
                error("array dimension not supplied");
            else
                e.trailingArray = true;

            e.arraySize.clear();
        }

        if (e.array) {
            int size;

            try {
                size = std::stoi(sizeStr);
            } catch (...) {
                error("expected array dimension, got `" + sizeStr + '\'');
            }

            if (!size)
                error("array dimension can't be zero");
        }

        p = skipWhiteSpace(p);

        if (e.array && *p++ != ']')
            error("missing ending `]'");
    }

    return p;
}

void SymbolFileParser::parseHookProcLine(const char *symStart, const char *symEnd, const char *start, const char *end)
{
    start = skipWhiteSpace(start);

    if (start == end)
        error("missing line number");

    int32_t line = 0;
    auto numStart = start;

    std::tie(line, start) = parseInt32(start, end);

    if (start == numStart)
        error("decimal numeric value expected");

    auto numEnd = start;

    if (line <= 0)
        error("line number must be positive non-zero integer");

    constexpr int kProcNameLength = ProcHookList::kProcNameLength;

    auto procLen = symEnd - symStart;
    if (procLen >= kProcNameLength)
        error("proc name too long");

    String hookName;
    char buf[kProcNameLength];

    start = skipWhiteSpace(start);
    if (*start == ',') {
        start = skipWhiteSpace(start + 1);

        if (start >= end)
            error("expected hook name");

        if (!isRemoveHook(start, end))
            hookName.assign(start, end);
    } else if (*start == '\n') {
        auto numLen = numEnd - numStart;
        if (procLen + numLen + 1 >= kProcNameLength)
            error("generated hook name too long");

        memcpy(buf, symStart, procLen);
        buf[procLen] = '_';

        memcpy(buf + procLen + 1, numStart, numLen);

        auto hookLen = procLen + numLen + 1;
        buf[hookLen] = '\0';

        hookName.assign(buf, hookLen);
    } else {
        commaExpectedError();
    }

    String procName(symStart, symEnd);
    m_procHookList.add(procName, hookName, line, m_lineNo);

    if (!hookName.empty()) {
        m_imports.add(hookName);
        m_importEntries.emplace(hookName);
    }
}

void SymbolFileParser::parseRemoveAndNullLine(SymbolAction action, const char *symStart, const char *symEnd,
    const char *start, const char *end)
{
    if (end - start != 4 || strncmp(start, kEndMarker, 4))
        ensureUniqueSymbol(start, end, kEndRange, action);

    auto flags = action;
    if (action == kRemove) {
        if (end > start)
            m_symbolTable.addSymbolAction(start, end, kRemoveEndRange, symStart, symEnd);
        else
            flags |= kRemoveSolo;
    }
    m_symbolTable.addSymbolAction(symStart, symEnd, flags, start, end);
}

bool SymbolFileParser::isRemoveHook(const char *start, const char *end)
{
    assert(end >= start);

    constexpr char kRemoveHook[] = "@remove";
    constexpr int kRemoveHookLen = sizeof(kRemoveHook) - 1;

    return end - start == kRemoveHookLen && !memcmp(start, kRemoveHook, kRemoveHookLen);
}

void SymbolFileParser::addHookProcs()
{
    auto procHookItems = m_procHookList.getItems();

    for (size_t i = 0; i < procHookItems.size(); ) {
        const auto item = &procHookItems[i];

        for (int j = i + 1; j < item->nextIndex; j++)
            if (procHookItems[j].line == procHookItems[j - 1].line)
                error("can't set more than one hook per line", procHookItems[j].definedAtLine);

        auto procHookData = m_procHookList.encodeProcHook(item, procHookItems.data() + item->nextIndex);
        m_symbolTable.addSymbolAction(item->procName, kInsertCall, procHookData);

        i = procHookItems[i].nextIndex;
    }
}

const char *SymbolFileParser::addExportEntry(const char *start, const char *p)
{
    assert(p > start);
    assert(m_exportEntries.capacity() > m_exportEntries.size());

    m_exportEntries.push_back({});
    auto& e = m_exportEntries.back();
    e.symbol = { start, p };

    bool requireArrayDimension = false;

    if (*p == ',') {
        std::tie(start, p) = getNextToken(p + 1);
        auto len = p - start;

        if (len >= 6 && (Util::isSpace(start[6]) || start[6] == ',') && !memcmp(start, "prefix", 6)) {
            std::tie(start, p) = getNextToken(start + 6);
            e.prefix = { start, p };
            p = skipWhiteSpace(p);

            if (e.prefix == ',')
                error("missing prefix");

            if (*p == '\n')
                return p;

            if (*p != ',')
                error("expecting comma after prefix");

            std::tie(start, p) = getNextToken(p + 1);
        }

        KeywordType keyword;
        std::tie(keyword, p) = lookupKeyword(start, p);

        switch (keyword) {
        case kFunction:
        case kFunctionPointer:
            if (keyword == kFunction)
                e.function = true;
            else
                e.functionPointer = true;

            p = skipWhiteSpace(p);
            if (*p != '\n')
                error(std::string("unexpected input after keyword `function") + (keyword == kFunction ? "" : "Pointer") + "'");
            break;

        case kPointer:
        case kPtr:
        case kArray:
            std::tie(start, p) = getNextToken(p);
            e.type = { start, p };
            e.array = true;
            requireArrayDimension = true;
            break;

        default:
            e.type = { start, p };
        }
    }

    p = skipWhiteSpace(p);
    p = handlePotentialArray(start, p, e);

    if (*p != '\n' && *p != '\r')
        error("unexpected input after end of export declaration");

    return p;
}

const char *SymbolFileParser::addImportEntry(const char *start, const char *p)
{
    assert(p > start);

    String functionName{ start, p };
    auto returnType = kVoid;

    p = skipWhiteSpace(p);

    if (*p == ',') {
        std::tie(start, p) = getNextToken(p + 1);
        auto len = p - start;

        if (len == 3 && !memcmp(start, "int", 3))
            returnType = kInt;
        else if (len != 4 || memcmp(start, "void", 4))
            error("only `int' and `void' supported as return types");
    }

    p = skipWhiteSpace(p);
    if (*p != '\n')
        error("unexpected input after end of import declaration");

    m_importEntries.emplace(functionName, returnType);

    return p;
}

std::pair<const char *, const char *> SymbolFileParser::getNextToken(const char *p)
{
    while (*p != '\n' && Util::isSpace(*p))
        p++;

    if (*p == '\n')
        error("identifier expected");

    auto start = p;

    do {
        p++;
    } while (*p != '\r' && *p != '\n' && *p != ',' && *p != '[' && *p != ']');

    if (*p == '[') {
        auto q = p - 1;
        while (Util::isSpace(*q) && q >= start)
            q--;
        if (*q == '*')
            p = q + 1;
    }

    return { start, p };
}

auto SymbolFileParser::lookupKeyword(const char *p, const char *limit) -> std::pair<KeywordType, const char *>
{
    auto maxLen = limit - p;
    auto notKeywordResult = std::make_pair(kNotKeyword, limit);

    if (maxLen >= 3) {
        if (Util::isSpace(p[3]))
            return !memcmp("ptr", p, 3) ? std::make_pair(kPtr, p + 3) : notKeywordResult;

        if (maxLen >= 5) {
            if (Util::isSpace(p[5]))
                return !memcmp("array", p, 5) ? std::make_pair(kArray, p + 5) : notKeywordResult;

            if (maxLen >= 7) {
                if (Util::isSpace(p[7]))
                    return !memcmp("pointer", p, 7) ? std::make_pair(kPointer, p + 7) : notKeywordResult;

                if (maxLen >= 8) {
                    if (Util::isSpace(p[8]))
                        return !memcmp("function", p, 8) ? std::make_pair(kFunction, p + 8) : notKeywordResult;

                    if (maxLen >= 15 && !memcmp("functionPointer", p, 15))
                        return { kFunctionPointer, p + 15 };
                }
            }
        }
    }

    return notKeywordResult;
};

void SymbolFileParser::ensureUniqueSymbol(const char *start, const char *end, Namespace symNamespace, SymbolAction action)
{
    const std::string& sym{ start, end };

    if (!sym.empty()) {
        auto res = m_symbolLine.insert(std::make_pair(std::make_pair(sym, symNamespace), std::make_pair(m_lineNo, action)));

        bool successfullyInserted = res.second;
        auto element = res.first;
        auto key = element->first;
        auto value = element->second;
        auto oldAction = value.second;

        if (!successfullyInserted) {
            static const auto kAllowedCombos = {
                std::make_pair(kExport, kInsertCall)
            };

            bool allowedCombo = false;

            for (const auto& symCombo : kAllowedCombos) {
                if (oldAction == symCombo.first && action == symCombo.second || oldAction == symCombo.second && action == symCombo.first) {
                    allowedCombo = true;
                    break;
                }
            }

            if (!allowedCombo) {
                auto symStr = key.first;
                auto ns = key.second;
                auto line = value.first;

                auto symName = "symbol";
                if (ns == kEndRange)
                    symName = "end of range";

                error(std::string("duplicate ") + symName + " found: `" + symStr + "', first defined at line " + std::to_string(line));
            }
        }
    }
}

const char *SymbolFileParser::skipWhiteSpace(const char * p)
{
    while (*p != '\n' && Util::isSpace(*p))
        p++;

    return p;
}

std::pair<int32_t, const char *> SymbolFileParser::parseInt32(const char *start, const char *end)
{
    int32_t num = 0;

    while (start < end && Util::isDigit(*start)) {
        if (num >= std::numeric_limits<int32_t>::max() / 10)
            error("integer overflow");

        num = num * 10 + *start++ - '0';
    }

    return { num, start };
}

void SymbolFileParser::error(const std::string& desc, int lineNo /* = -1 */) const
{
    if (lineNo <= 0)
        lineNo = m_lineNo;

    Util::exit("%s(%d): %s", 1, Util::getFilename(m_path), lineNo, desc.c_str());
}

void SymbolFileParser::commaExpectedError() const
{
    error("comma (`,') expected");
}

void SymbolFileParser::xfwrite(const char *buf, size_t len)
{
    assert(m_headerFile);

    if (fwrite(buf, len, 1, m_headerFile) != 1)
        Util::exit("Error writing %s", EXIT_FAILURE, m_headerPath);
}

void SymbolFileParser::xfwrite(const String& str)
{
    xfwrite(str.str(), str.length());
}

template <size_t N> void SymbolFileParser::xfwrite(const char (&buf)[N])
{
    xfwrite(buf, N - 1);
}
