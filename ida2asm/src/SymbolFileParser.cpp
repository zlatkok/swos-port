#include "SymbolFileParser.h"
#include "AmigaRegs.h"
#include "Util.h"

constexpr int kProcCapacity = 9000;
constexpr int kImportsCapacity = 3000;
constexpr int kExportsCapacity = 5000;
constexpr int kReplacementsCapacity = 400;
constexpr int kMaxExportEntries = 400;

SymbolFileParser::SymbolFileParser(const char *symbolFilePath, const char *headerFilePath)
    : m_path(symbolFilePath), m_headerPath(headerFilePath), m_procs(kProcCapacity), m_replacements(kReplacementsCapacity),
    m_imports(kImportsCapacity), m_exports(kExportsCapacity)
{
    auto result = Util::loadFile(symbolFilePath, true);
    m_data.reset(result.first);
    m_dataSize = result.second;
    m_exportEntries.reserve(kMaxExportEntries);
    parseSymbolFile();
}

void SymbolFileParser::outputHeaderFile(const char *path)
{
    auto file = fopen(path, "w");
    if (!file)
        Util::exit("Could not open %s for write", EXIT_FAILURE, path);

    static const char kHeader[] =
        "// automatically generated by ida2asm [don't edit!]\n\n"
        "#pragma once\n\n"

        "#include \"swos.h\"\n\n"

        "#pragma pack(push, 1)\n"
        "struct Register\n{\n"
        "    Register(byte b) : data(b) {}\n"
        "    Register(word w) : data(w) {}\n"
        "    Register(dword d) : data(d) {}\n"
        "    Register(int i) : data(i) {}\n"
        "    Register(const char *p) : data(reinterpret_cast<dword>(p)) {}\n"
        "    template <typename T> Register(T t) { assign<T>(t); }\n"
        "    template <typename T> void assign(typename std::enable_if<std::is_convertible<T, dword>::value, T>::type t) {\n"
        "        data = static_cast<dword>(t);\n"
        "    }\n"
        "    template <typename T> void assign(typename std::enable_if<!std::is_convertible<T, dword>::value, T>::type t) {\n"
        "        data = reinterpret_cast<dword>(t);\n"
        "    }\n"
        "    word asWord() const { return static_cast<word>(data); }\n"
        "    int16_t asInt16() const { return static_cast<int16_t>(data); }\n"
        "    dword asDword() const { return static_cast<dword>(data); }\n"
        "    int asInt() const { return static_cast<int>(data); }\n"
        "    template <typename T> typename std::enable_if<std::is_convertible<T, dword>::value, T>::type as() {\n"
        "         return static_cast<T>(data);\n"
        "    }\n"
        "    template <typename T> typename std::enable_if<!std::is_convertible<T, dword>::value, T>::type as() {\n"
        "        return reinterpret_cast<T>(data);\n"
        "    }\n"
        "    template <typename T> const T as() const { return reinterpret_cast<T>(data); }\n"
        "    char *asPtr() { return reinterpret_cast<char *>(data); }\n"
        "    const char *asPtr() const { return reinterpret_cast<char *>(data); }\n"
        "    template <typename T> operator T*() const { return reinterpret_cast<T *>(data); }\n"
        "    operator dword() const { return data; }\n"
        "    Register& operator+=(size_t n) { data += n; return *this; }\n"
        "    dword data;\n"
        "};\n"
        "#pragma pack(pop)\n\n"

        "constexpr int k68kRegisterTotalSize = 15 * 4;\n\n"

        "struct MenuBase;\n\n"

        "extern \"C\" {\n"
        "    extern Register ";

    xfwrite(file, kHeader);

    for (int i = 0; i < kNumAmigaRegisters - 1; i++) {
        xfwrite(file, indexToAmigaRegister(i));
        xfwrite(file, ", ");
    }

    xfwrite(file, indexToAmigaRegister(kNumAmigaRegisters - 1));
    xfwrite(file, ";\n");

    for (const auto& exp : m_exportEntries) {
        xfwrite(file, "    extern ");

        if (exp.function || exp.functionPointer) {
            xfwrite(file, "void ");

            if (exp.functionPointer)
                xfwrite(file, "(*");

            if (!exp.prefix.empty())
                xfwrite(file, exp.prefix);
            xfwrite(file, exp.symbol);

            if (exp.functionPointer)
                xfwrite(file, ")");

            xfwrite(file, "();");
        } else {
            xfwrite(file, exp.type);
            if (!exp.type.endsWith('*'))
                xfwrite(file, " ");

            if (!exp.prefix.empty())
                xfwrite(file, exp.prefix);
            xfwrite(file, exp.symbol);

            if (exp.array) {
                xfwrite(file, "[");
                if (!exp.arraySize.empty())
                    xfwrite(file, exp.arraySize);
                xfwrite(file, "]");
            }

            xfwrite(file, ";");
        }

        xfwrite(file, "\n");
    }

    // put imports into namespace to avoid name clashes
    if (!m_imports.empty())
        xfwrite(file, "\n    namespace SWOS {\n");

    for (const auto& imp : m_imports) {
        xfwrite(file, "        extern void ");
        xfwrite(file, imp);
        xfwrite(file, "();\n");
    }

    if (!m_imports.empty())
        xfwrite(file, "    }\n");

    xfwrite(file, "}\n");

    fclose(file);
}

auto SymbolFileParser::symbolAction(CToken *sym) const -> std::pair<SymbolAction, String>
{
    assert(sym && sym->isId() && sym->textLength);

    return lookupSymbolAction(sym);
}

auto SymbolFileParser::lookupSymbolAction(const String& sym) const -> std::pair<SymbolAction, String>
{
    auto holders = m_procs.getAll(sym);
    auto result = std::make_pair(kNone, String());

    for (const auto holder : holders) {
        result.first |= holder->action();

        assert(result.second.empty() || holder->endSymbol().empty());

        if (!holder->endSymbol().empty())
            result.second = holder->endSymbol();

        holder->setAction(kNone);
    }

    return result;
}

String SymbolFileParser::symbolReplacement(const String& sym) const
{
    auto holder = m_replacements.get(sym);

    if (holder) {
        assert(holder->action() == kReplace);
        return holder->endSymbol();
    }

    return {};
}

const std::vector<String> SymbolFileParser::unusedSymbolsForRemoval() const
{
    std::vector<String> result;

    for (const auto& it : m_procs)
        if (it->cargo->action() != kNone)
            result.push_back(it->text);

    return result;
}

const StringList& SymbolFileParser::exports() const
{
    return m_exports;
}

const StringList& SymbolFileParser::imports() const
{
    return m_imports;
}

void SymbolFileParser::parseSymbolFile()
{
    assert(m_data && m_dataSize);

    auto p = m_data.get();
    auto sentinel = p + m_dataSize;

    auto action = SymbolAction::kNone;

    while (true) {
        while (Util::isSpace(*p) && p < sentinel) {
            m_lineNo += *p == '\n';
            p++;
        }

        if (p >= sentinel) {
            break;
        } else if (*p == '#') {
            while (*p != '\n')
                p++;
            continue;
        } else if (*p == '@') {
            auto start = ++p;

            while (!Util::isSpace(*p))
                p++;

            action = getSectionName(start, p);

            if (action == kNone)
                error(std::string("unknown directive: ") + std::string(p, start - p));
        } else {
            if (action == kNone)
                error("directive expected");

            auto start = p;
            while (!Util::isSpace(*p) && *p != '-' && *p != ',')
                p++;

            auto symStart = start;
            auto symEnd = p;

            if (action == kReplace || action == kInsertCall) {
                while (Util::isSpace(*p) && *p != '\n')
                    p++;

                if (*p != ',')
                    error("comma (`,') expected");

                do {
                    p++;
                } while (Util::isSpace(*p) && *p != '\n');

                start = p;

                while (*p != '\n')
                    p++;
            } else {
                while (*p != '\n' && Util::isSpace(*p))
                    p++;

                if (*p == '-') {
                    do {
                        p++;
                    } while (Util::isSpace(*p));

                    start = p;
                    do {
                        p++;
                    } while (!Util::isSpace(*p));

                    if (p == start)
                        error("end of range missing");
                } else {
                    start = p;
                }
            }

            if (action == kRemove || action == kNull || action == kInsertCall) {
                ensureUniqueSymbol(symStart, symEnd, kGlobal, action);
                if (action == kInsertCall) {
                    if (p == start)
                        error("missing line number");

                    int32_t line = 0;
                    while (start < p && !Util::isSpace(*start)) {
                        if (*start < '0' || *start > '9')
                            error("decimal numeric value expected");

                        line = line * 10 + *start++ - '0';
                    }

                    if (!line)
                        error("line number can't be zero");

                    auto len = symEnd - symStart;
                    m_procs.add(symStart, len, kInsertCall, reinterpret_cast<char *>(&line), 4);

                    char buf[512];
                    memcpy(buf, symStart, len);
                    buf[len] = '_';
                    auto lineString = std::to_string(line);
                    memcpy(buf + len + 1, lineString.c_str(), lineString.length());

                    m_imports.add(buf, buf + len + 1 + lineString.length());
                } else {
                    ensureUniqueSymbol(start, p, kEndRange, action);
                    m_procs.add(symStart, symEnd - symStart, action, start, p - start);
                }
            } else {
                if (action != kReplace && action != kInsertCall && start != p)
                    error("ranges only supported for removing/nullifying procs/data items");

                auto ns = kGlobal;
                if (action == kSaveCppRegisters)
                    ns = kSaveRegs;
                else if (action == kOnEnter)
                    ns = kOnEnterNs;
                else if (action == kReplace)
                    ns = kReplaceNs;

                ensureUniqueSymbol(symStart, symEnd, ns, action);

                if (action == kExport || action == kImport) {
                    if (action == kExport) {
                        p = addExportEntry(symStart, symEnd);
                        m_exports.add(symStart, symEnd);
                    } else {
                        m_imports.add(symStart, symEnd);
                        m_procs.add(symStart, symEnd - symStart, kRemove, nullptr, 0);
                    }
                } else if (action == kSaveCppRegisters || action == kOnEnter) {
                    m_procs.add(symStart, symEnd - symStart, action, nullptr, 0);
                    if (action == kOnEnter) {
                        char buf[256];
                        auto len = symEnd - symStart;

                        memcpy(buf, symStart, len);
                        strcpy(buf + len, Util::kOnEnterSuffix);

                        m_imports.add(buf, buf + len + sizeof(Util::kOnEnterSuffix) - 1);
                    }
                } else if (action == kReplace) {
                    if (p == start)
                        error("missing replacement content");

                    m_replacements.add(symStart, symEnd - symStart, kReplace, start, p - start + 1);
                }
            }

            while (*p != '\n' && Util::isSpace(*p))
                p++;

            if (*p != '\n')
                error("unexpected input encountered");
        }
    }

    m_procs.seal();
    m_replacements.seal();

    // we won't need this any longer
    m_symbolLine.clear();
}

auto SymbolFileParser::getSectionName(const char *begin, const char *end) -> SymbolAction
{
    auto action = kNone;
    auto len = end - begin;

    if (len == 6) {
        if (!memcmp(begin, "remove", 6)) {
            action = kRemove;
        } else if (!memcmp(begin, "export", 6)) {
            action = kExport;
        } else if (!memcmp(begin, "import", 6)) {
            action = kImport;
        }
    } else if (len == 4) {
        if (!memcmp(begin, "null", 4))
            action = kNull;
    } else if (len == 7) {
        if (!memcmp(begin, "replace", 7))
            action = kReplace;
    } else if (len == 8) {
        if (!memcmp(begin, "on-enter", 8))
            action = kOnEnter;
    } else if (len == 9) {
        if (!memcmp(begin, "save-regs", 9))
            action = kSaveCppRegisters;
    } else if (len == 11) {
        if (!memcmp(begin, "insert-hook", 11))
            action = kInsertCall;
    }

    return action;
}

const char *SymbolFileParser::addExportEntry(const char *start, const char *p)
{
    assert(p > start);
    assert(m_exportEntries.capacity() > m_exportEntries.size());

    m_exportEntries.push_back({});
    auto& e = m_exportEntries.back();
    e.symbol = { start, p };

    auto skipWhiteSpace = [&p]() {
        while (*p != '\n' && Util::isSpace(*p))
            p++;
    };

    if (*p == ',') {
        std::tie(start, p) = getNextToken(p + 1);
        auto len = p - start;

        if (len >= 6 && (Util::isSpace(start[6]) || start[6] == ',') && !memcmp(start, "prefix", 6)) {
            std::tie(start, p) = getNextToken(start + 6);
            e.prefix = { start, p };
            skipWhiteSpace();

            if (e.prefix == ',')
                error("missing prefix");

            if (*p == '\n')
                return p;

            if (*p != ',')
                error("expecting comma after prefix");

            std::tie(start, p) = getNextToken(p + 1);
        }

        KeywordType keyword;
        std::tie(keyword, p) = lookupKeyword(start, p);

        switch (keyword) {
        case kFunction:
        case kFunctionPointer:
            if (keyword == kFunction)
                e.function = true;
            else
                e.functionPointer = true;

            skipWhiteSpace();
            if (*p != '\n')
                error(std::string("unexpected input after keyword `function") + (keyword == kFunction ? "" : "Pointer") + "'");
            break;

        case kPointer:
        case kPtr:
        case kArray:
            std::tie(start, p) = getNextToken(p);
            e.type = { start, p };
            e.array = true;
            skipWhiteSpace();

            if (*p == '[') {
                std::tie(start, p) = getNextToken(p + 1);
                std::string sizeStr = { start, p };
                e.arraySize = { start, p };

                if (sizeStr == "]")
                    error("array dimension not supplied");

                int size;

                try {
                    size = std::stoi(sizeStr);
                } catch (...) {
                    error("expected array dimension, got `" + sizeStr + '\'');
                }

                if (!size)
                    error("array dimension can't be zero");

                skipWhiteSpace();

                if (*p++ != ']')
                    error("missing ending `]'");
            }
            break;

        default:
            e.type = { start, p };
        }
    }

    skipWhiteSpace();
    if (*p != '\n')
        error("unexpected input after end of export declaration");

    return p;
}

std::pair<const char *, const char *> SymbolFileParser::getNextToken(const char *p)
{
    while (*p != '\n' && Util::isSpace(*p))
        p++;

    if (*p == '\n')
        error("identifier expected");

    auto start = p;

    do {
        p++;
    } while (*p != '\r' && *p != '\n' && *p != ',' && *p != '[' && *p != ']');

    if (*p == '[') {
        auto q = p - 1;
        while (Util::isSpace(*q) && q >= start)
            q--;
        if (*q == '*')
            p = q + 1;
    }

    return { start, p };
}

auto SymbolFileParser::lookupKeyword(const char *p, const char *limit) -> std::pair<KeywordType, const char *>
{
    auto maxLen = limit - p;
    auto notKeywordResult = std::make_pair(kNotKeyword, limit);

    if (maxLen >= 3) {
        if (Util::isSpace(p[3]))
            return !memcmp("ptr", p, 3) ? std::make_pair(kPtr, p + 3) : notKeywordResult;

        if (maxLen >= 5) {
            if (Util::isSpace(p[5]))
                return !memcmp("array", p, 5) ? std::make_pair(kArray, p + 5) : notKeywordResult;

            if (maxLen >= 7) {
                if (Util::isSpace(p[7]))
                    return !memcmp("pointer", p, 7) ? std::make_pair(kPointer, p + 7) : notKeywordResult;

                if (maxLen >= 8) {
                    if (Util::isSpace(p[8]))
                        return !memcmp("function", p, 8) ? std::make_pair(kFunction, p + 8) : notKeywordResult;

                    if (maxLen >= 15 && !memcmp("functionPointer", p, 15))
                        return { kFunctionPointer, p + 15 };
                }
            }
        }
    }

    return notKeywordResult;
};

void SymbolFileParser::ensureUniqueSymbol(const char *start, const char *end, Namespace symNamespace, SymbolAction action)
{
    const std::string& sym{ start, end };

    if (!sym.empty()) {
        auto res = m_symbolLine.insert(std::make_pair(std::make_tuple(sym, symNamespace, action), m_lineNo));

        bool successfullyInserted = res.second;
        auto element = res.first;
        auto oldAction = std::get<2>(element->first);

        if (!successfullyInserted && (oldAction != kImport || action != kRemove) && (oldAction != kRemove || action != kImport)) {
            auto line = element->second;
            auto endOfRange = std::get<1>(element->first);
            auto sym = std::get<0>(element->first);

            if (!endOfRange)
                error("duplicate symbol found: `" + sym + "', first defined at line " + std::to_string(line));
            else
                error("duplicate end of range: `" + sym + '\'');
        }
    }
}

void SymbolFileParser::error(const std::string& desc)
{
    Util::exit("%s(%d): %s", 1, Util::getFilename(m_path), m_lineNo, desc.c_str());
}

void SymbolFileParser::xfwrite(FILE *file, const char *buf, size_t len)
{
    if (fwrite(buf, len, 1, file) != 1)
        Util::exit("Error writing %s", EXIT_FAILURE, m_headerPath);
}

void SymbolFileParser::xfwrite(FILE *file, const String& str)
{
    xfwrite(file, str.str(), str.length());
}

template <size_t N> void SymbolFileParser::xfwrite(FILE *file, const char (&buf)[N])
{
    xfwrite(file, buf, N - 1);
}
