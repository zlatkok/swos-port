// Two's complement integer representation is assumed.

#include "COutput.h"
#include "COutput.h"

#define kVmHeaderFilename     "vm.h"
#define kAutoGeneratedWarning "// " kAutoGeneratedWarningText "\n\n"

constexpr int kAverageBytesPerStruct = 750;
constexpr int kInProcLabelsCapacity = 30'000;

constexpr auto kDefsFilename = "defs.h";

constexpr auto kSwitchTableName = "menuTypesJumpTable";

// specifically tagged struct vars since IDA will erase their type, keep it sorted
const std::vector<String> COutput::m_spriteStructVars = {
    "advertIngameSprites",
    "ballShadowSprite",
    "ballSprite",
    "big_S_Sprite",
    "bookedPlayerSprite",
    "cornerFlagSprite",
    "currentPlayerNameSprite",
    "currentTimeSprite",
    "dashSprite",
    "goal1TopSprite",
    "goal2BottomSprite",
    "goalie1Sprite",
    "goalie2Sprite",
    "gridBottomRowLeftSprite",
    "gridBottomRowRightSprite",
    "gridMiddleRowLeftSprite",
    "gridMiddleRowRightSprite",
    "gridUpperRowLeftSprite",
    "gridUpperRowRightSprite",
    "playerMarkSprite",
    "refereeSprite",
    "resultAfterTheGame",
    "resultOnHalftime",
    "team1CurPlayerNumSprite",
    "team1GoalsDigit1Sprite",
    "team1GoalsDigit2Sprite",
    "team1NameSprite",
    "team1Player10Sprite",
    "team1Player11Sprite",
    "team1Player2Sprite",
    "team1Player3Sprite",
    "team1Player4Sprite",
    "team1Player5Sprite",
    "team1Player6Sprite",
    "team1Player7Sprite",
    "team1Player8Sprite",
    "team1Player9Sprite",
    "team1Scorer1Sprite",
    "team1Scorer2Sprite",
    "team1Scorer3Sprite",
    "team1Scorer4Sprite",
    "team1Scorer5Sprite",
    "team1Scorer6Sprite",
    "team1Scorer7Sprite",
    "team1Scorer8Sprite",
    "team1TotalGoalsDigit1Sprite",
    "team1TotalGoalsDigit2Sprite",
    "team2CurPlayerNumSprite",
    "team2GoalsDigit1Sprite",
    "team2GoalsDigit2Sprite",
    "team2NameSprite",
    "team2Player10Sprite",
    "team2Player11Sprite",
    "team2Player2Sprite",
    "team2Player3Sprite",
    "team2Player4Sprite",
    "team2Player5Sprite",
    "team2Player6Sprite",
    "team2Player7Sprite",
    "team2Player8Sprite",
    "team2Player9Sprite",
    "team2Scorer1Sprite",
    "team2Scorer2Sprite",
    "team2Scorer3Sprite",
    "team2Scorer4Sprite",
    "team2Scorer5Sprite",
    "team2Scorer6Sprite",
    "team2Scorer7Sprite",
    "team2Scorer8Sprite",
    "team2TotalGoalsDigit1Sprite",
    "team2TotalGoalsDigit2Sprite",
};

COutput::COutput(const char *path, const SymbolFileParser& symFileParser, const StructStream& structs, const DefinesMap& defines,
    const References& references, const OutputItemStream& outputItems)
:
    OutputWriter(path, symFileParser, structs, defines, references, outputItems),
    m_structMap(structs.count() * kAverageBytesPerStruct), m_inProcLabels(kInProcLabelsCapacity)
{
    fillStructInfo();
}

void COutput::setCImportSymbols(const StringList *syms)
{
    m_cImportSymbols = syms;
}

void COutput::setCExportSymbols(const StringList *syms)
{
    m_cExportSymbols = syms;
}

bool COutput::output(OutputFlags flags, CToken *openingSegment /* = nullptr */)
{
#ifndef NDEBUG
    // we'll need bigger output buffer to accommodate original instructions as comments
    int size = 3 * (m_structs.size() + m_defines.size() + m_outputItems.size());
#else
    int size = -1;
#endif

    if (!openOutputFile(flags, size))
        return false;

    if (!flags)
        return true;

    out("// " kAutoGeneratedWarningText, Util::kNewLine, Util::kNewLine);

    bool isDefineFile = flags & (kStructs | kDefines) && !(flags & kFullDisasembly);
    if (isDefineFile) {
        if (!outputVmFiles()) {
            closeOutputFile();
            return false;
        }
        out("#pragma once", Util::kNewLine, Util::kNewLine);
    } else {
        out("#include \"" kVmHeaderFilename, '"', Util::kNewLine);
        out("#include \"", getDefsFilename(), '"', Util::kNewLine, Util::kNewLine);
        out("#pragma pack(push, 1)", Util::kNewLine, Util::kNewLine);
    }

    bool result = true;
    if ((flags & kExterns) && !outputExterns())
        result = false;

    // we'll make everything public (so no need to output them explicitly)

    if (flags & kStructs)
        outputStructs();

    if (flags & kDefines)
        outputDefines();

    if (flags & kDisassembly) {
        outputCodeAndData();
        out("#pragma pack(pop)", Util::kNewLine);
    }

    if (!save())
        result = false;

    closeOutputFile();

    return result;
}

const char *COutput::getDefsFilename() const
{
    return kDefsFilename;
}

bool COutput::outputFile(const char *filename, const char *contents, size_t size)
{
    const auto& outputBasePath = getOutputBaseDir();
    const auto& vmFilePath = Util::joinPaths(outputBasePath, filename);

    auto f = fopen(vmFilePath.c_str(), "w");
    if (!f)
        return false;

    auto result = fwrite(contents, size, 1, f) == 1;

    fclose(f);
    return result;
}

bool COutput::outputVmFiles()
{
    constexpr char kVmCFilename[] = "vm.c";
    constexpr char kVmHeaderContents[] =
        kAutoGeneratedWarning
        "#pragma once\n\n"
        "#include <stdlib.h>\n"
        "#include <stdint.h>\n\n"

        "#define false 0\n"
        "#define true 1\n\n"

        "typedef uint8_t bool;\n"
        "typedef uint8_t byte;\n"
        "typedef uint16_t word;\n"
        "typedef uint32_t dword;\n\n"

        "#pragma pack(push, 1)\n\n"
        "union Register {\n"
        "    int32_t all;\n"
        "    struct {\n"
        "        int16_t hi16;\n"
        "        union {\n"
        "            int16_t lo16;\n"
        "            struct {\n"
        "                int8_t hi8;\n"
        "                int8_t lo8;\n"
        "            };\n"
        "        };\n"
        "    };\n"
        "};\n"
        "\nstruct Flags\n"
        "{\n"
        "    bool carry;\n"
        "    bool zero;\n"
        "    bool sign;\n"
        "    bool overflow;\n"
        "    bool direction;\n"
        "};\n"
        "typedef struct Flags Flags;\n"
        "\n#pragma pack(pop)\n\n"

        "extern union Register g_eax, g_ebx, g_ecx, g_edx, g_esi, g_edi, g_ebp, g_tmp;\n"
        "extern Flags g_flags;\n"
        "extern int32_t g_stackTop;\n"
        "extern int32_t g_stack[1024];\n\n"
        "#define push(a) (g_stack[--g_stackTop] = (a))\n"
        "#define pop(a) ((a) = g_stack[g_stackTop++])\n\n"
        "#define eax (g_eax.all)\n"
        "#define ebx (g_ebx.all)\n"
        "#define ecx (g_ecx.all)\n"
        "#define edx (g_edx.all)\n"
        "#define esi (g_esi.all)\n"
        "#define edi (g_edi.all)\n"
        "#define ebp (g_ebp.all)\n"
        "#define ax (g_eax.lo16)\n"
        "#define bx (g_ebx.lo16)\n"
        "#define cx (g_ecx.lo16)\n"
        "#define dx (g_edx.lo16)\n"
        "#define si (g_esi.lo16)\n"
        "#define di (g_edi.lo16)\n"
        "#define bp (g_ebp.lo16)\n"
        "#define ah (g_eax.hi8)\n"
        "#define al (g_eax.lo8)\n"
        "#define bh (g_ebx.hi8)\n"
        "#define bl (g_ebx.lo8)\n"
        "#define ch (g_ecx.hi8)\n"
        "#define cl (g_ecx.lo8)\n"
        "#define dh (g_edx.hi8)\n"
        "#define dl (g_edx.lo8)\n\n"

        "#undef __out  // some VC++ weirdness\n"
    ;
    constexpr char kVmCFileContents[] =
        kAutoGeneratedWarning
        "#include \"" kVmHeaderFilename "\"\n\n"
        "Flags g_flags;\n"
        "Register g_eax, g_ebx, g_ecx, g_edx, g_esi, g_edi, g_ebp, g_tmp;\n"
        "int32_t g_stack[1024];\n"
        "int32_t g_stackTop = sizeof(g_stack) / sizeof(g_stack[0]);\n"
    ;

    return outputFile(kVmHeaderFilename, kVmHeaderContents, sizeof(kVmHeaderContents) -1) &&
        outputFile(kVmCFilename, kVmCFileContents, sizeof(kVmCFileContents) -1);
}

void COutput::outputStructs()
{
    if (!m_structs.empty())
        out("#pragma pack(push, 1)", Util::kNewLine);

    for (auto& struc : m_structs) {
        if (struc.resolved())
            continue;

        for (const auto& field : struc) {
            if (!field.byteSize()) {
                auto structName = field.type();
                auto nestedStruct = m_structs.findStruct(structName);

                assert(nestedStruct);
                if (nestedStruct && !nestedStruct->resolved())
                    outputStruct(*nestedStruct);
            }
        }

        outputStruct(struc);
    }

    if (!m_structs.empty())
        out("#pragma pack(pop)", Util::kNewLine);
}

void COutput::outputStruct(Struct& struc)
{
    outputComment(struc.leadingComments(), false);
    out(struc.isUnion() ? "union " : "struct ", struc.name(), Util::kNewLine, '{', Util::kNewLine);

    char anonBuf[32];
    int anonCounter = 0;

    for (const auto& field : struc) {
        if (!field.type().empty()) {
            out(kIndent, field.type(), ' ');
        } else {
            auto sizeSpecifier = getTypeInfo(field.byteSize()).unsignedType;
            out(kIndent, sizeSpecifier, ' ');
        }

        if (!field.name().empty()) {
            out(field.name());
        } else {
            sprintf(anonBuf, "%02d", anonCounter++);
            out(anonBuf);
        }

        if (!field.dup().empty())
            out('[', field.dup(), ']');

        out(';', Util::kNewLine);
    }

    out("};", Util::kNewLine);
    out("typedef ", struc.isUnion() ? "union " : "struct ", struc.name(), ' ', struc.name(), ';', Util::kNewLine);
    struc.resolve();
}

bool COutput::outputExterns()
{
    if (m_references.externs().empty())
        return true;

    bool result = true;

    for (auto ext : m_references.externs()) {
        const auto& name = std::get<0>(ext);
        const auto& refType = std::get<1>(ext);
        const auto& customType = std::get<2>(ext);

        assert(name.length() && name.str());

        out("extern ");

        if (isSpriteVar(name)) {
            out("Sprite");
        } else {
            switch (refType) {
            case References::kByte: out("int8_t"); break;
            case References::kWord: out("int16_t"); break;
            case References::kDword: out("int32_t"); break;
            case References::kQWord: out("int64_t"); break;
            case References::kTbyte: out("int8_t"); break;
            case References::kNear:
            case References::kProc: out("void"); break;
            case References::kUser: out(customType); break;
            default:
                if (!m_error.empty())
                    m_error += '\n';
                m_error += std::string("undefined reference found: ") + name.string();
                result = false;
            }
        }

        out(' ', name);
        if (refType == References::kNear || refType == References::kProc)
            out("()");
        else if (refType == References::kTbyte)
            out("[10]");

        out(';', Util::kNewLine);
    }

    out(Util::kNewLine);

    return result;
}

void COutput::outputDefines()
{
    for (auto it : m_defines) {
        auto def = it.cargo;

        outputComment(def->leadingComments(), false);
        out("#define ", def->name(), " ");

        if (def->isInverted())
            out('~');

        if (def->value().endsWith('h'))
            out("0x", def->value().withoutLast());
        else
            out(def->value());

        outputComment(def->comment());
    }
}

void COutput::outputCodeAndData()
{
    outputForwardDeclarationsAndTagLabels();

    for (auto it = m_outputItems.begin(); it != m_outputItems.end(); ++it) {
        auto nextItem = it->next() != m_outputItems.end() ? it->next() : nullptr;

        switch (it->type()) {
        case OutputItem::kInstruction:
            {
                auto instruction = it->getItem<Instruction>();
                auto skipped = checkForSwitchTable(it, instruction);
                if (skipped != it) {
                    it = skipped;
                    continue;
                }

                assert(it != m_outputItems.end());

                if (!nextItem || isFinalRetn(*it))
                    continue;

                outputInstruction(instruction);
            }
            break;
        case OutputItem::kDataItem:
            {
                auto dataItem = it->getItem<DataItem>();
                auto skipped = checkForSwitchTable(it, dataItem);
                if (skipped != it) {
                    it = skipped;
                    continue;
                }

                outputDataItem(it->getItem<DataItem>(), nextItem, false);
            }
            break;
        case OutputItem::kProc:
            outputProc(it->getItem<Proc>());
            break;
        case OutputItem::kEndProc:
            outputEndProc(it->getItem<EndProc>(), it->comment(), it->next());
            break;
        case OutputItem::kLabel:
            outputLabel(it->getItem<Label>());
            break;
        case OutputItem::kStackVariable:
            outputStackVariable(it->getItem<StackVariable>());
            break;
            // ignore everything else and hope it doesn't blow up
        }
    }

    if (m_insideProc)
        out('}', Util::kNewLine);
}

// Since assembler might reference labels without declaring them first, we'll simply forward declare all the data.
// Also divide labels into global (outside a proc) and local (inside a proc).
void COutput::outputForwardDeclarationsAndTagLabels()
{
    bool inProc = false;

    for (auto it = m_outputItems.begin(); it != m_outputItems.end(); ++it) {
        switch (it->type()) {
        case OutputItem::kDataItem:
            {
                auto dataItem = it->getItem<DataItem>();
                auto skipped = checkForSwitchTable(it, dataItem);

                if (skipped != it) {
                    it = skipped;
                    continue;
                }

                auto nextItem = it->next() != m_outputItems.end() ? it->next() : nullptr;
                outputDataItem(dataItem, nextItem, true);
            }
            break;
        case OutputItem::kProc:
            {
                auto proc = it->getItem<Proc>();
                out("void ", proc->name(), "();", Util::kNewLine);
                inProc = true;
            }
            break;
        case OutputItem::kEndProc:
            inProc = false;
            break;
        case OutputItem::kLabel:
            if (inProc) {
                auto label = it->getItem<Label>();
                if (!label->isLocal())
                    m_inProcLabels.add(label->name());
            }
            break;
        }
    }

    out(Util::kNewLine);

    m_dataIndex = 0;
    m_inProcLabels.seal();
}

void COutput::outputInstruction(const Instruction *instruction)
{
    ensureFunction();

    assert(m_insideProc);
    out(kIndent);

    auto initialOutputPtr = getOutputPtr();

    switch (instruction->type()) {
    case Token::T_NOP:
        // ignore
        break;
    case Token::T_MOV:
    case Token::T_MOVZX:
    case Token::T_MOVSX:
        outputMov(instruction);
        break;
    case Token::T_MOVSB:
    case Token::T_MOVSW:
    case Token::T_MOVSD:
        outputMovs(instruction);
        break;
    case Token::T_LODSB:
    case Token::T_LODSW:
    case Token::T_LODS:
        outputLods(instruction);
        break;
    case Token::T_STOSB:
    case Token::T_STOSW:
    case Token::T_STOSD:
        outputStos(instruction);
        break;
    case Token::T_CALL:
        outputCall(instruction);
        break;
    case Token::T_PUSH:
    case Token::T_POP:
        outputPushPop(instruction);
        break;
    case Token::T_CBW:
        outputCbw(instruction);
        break;
    case Token::T_CWDE:
        outputCwde(instruction);
        break;
    case Token::T_CDQ:
        outputCdq(instruction);
        break;
    case Token::T_RETN:
        out("return");
        break;
    case Token::T_JMP:
        outputJmp(instruction);
        break;
    case Token::T_JG:
        outputJg(instruction);
        break;
    case Token::T_JGE:
        outputJge(instruction);
        break;
    case Token::T_JL:
        outputJl(instruction);
        break;
    case Token::T_JZ:
        outputJz(instruction);
        break;
    case Token::T_JNZ:
        outputJnz(instruction);
        break;
    case Token::T_JS:
        outputJs(instruction);
        break;
    case Token::T_JNS:
        outputJns(instruction);
        break;
    case Token::T_JA:
        outputJa(instruction);
        break;
    case Token::T_JB:
        outputJb(instruction);
        break;
    case Token::T_JNB:
        outputJnb(instruction);
        break;
    case Token::T_JBE:
        outputJbe(instruction);
        break;
    case Token::T_JO:
        outputJo(instruction);
        break;
    case Token::T_JNO:
        outputJno(instruction);
        break;
    case Token::T_JLE:
        outputJle(instruction);
        break;
    case Token::T_OR:
    case Token::T_XOR:
        outputOrXor(instruction);
        break;
    case Token::T_CMP:
        outputCmpSubAdd(instruction, false, false);
        break;
    case Token::T_INC:
        outputIncDec(instruction, true);
        break;
    case Token::T_DEC:
        outputIncDec(instruction, false);
        break;
    case Token::T_AND:
        outputAndTest(instruction, true);
        break;
    case Token::T_XCHG:
        outputXchg(instruction);
        break;
    case Token::T_SUB:
        outputCmpSubAdd(instruction, true, false);
        break;
    case Token::T_ADD:
        outputCmpSubAdd(instruction, true, true);
        break;
    case Token::T_MUL:
        outputMul(instruction);
        break;
    case Token::T_IMUL:
        outputImul(instruction);
        break;
    case Token::T_DIV:
    case Token::T_IDIV:
        outputDiv(instruction);
        break;
    case Token::T_TEST:
        outputAndTest(instruction, false);
        break;
    case Token::T_SHL:
    case Token::T_SHR:
    case Token::T_SAR:
        outputShift(instruction);
        break;
    case Token::T_RCR:
    case Token::T_RCL:
    case Token::T_ROL:
    case Token::T_ROR:
        outputRotate(instruction);
        break;
    case Token::T_INT:
    case Token::T_IN:
    case Token::T_OUT:
    case Token::T_CLI:
    case Token::T_STI:
        outputIntInOut(instruction);
        break;
    case Token::T_NEG:
        outputNeg(instruction);
        break;
    case Token::T_NOT:
        outputNot(instruction);
        break;
    case Token::T_LOOP:
        outputLoop(instruction);
        break;
    case Token::T_PUSHF:
        outputPushf(instruction);
        break;
    case Token::T_POPF:
        outputPopf(instruction);
        break;
    case Token::T_PUSHA:
        outputPusha(instruction);
        break;
    case Token::T_POPA:
        outputPopa(instruction);
        break;
    case Token::T_STC:
        outputStc(instruction);
        break;
    case Token::T_CLC:
        outputClc(instruction);
        break;
    case Token::T_CLD:
        outputCld(instruction);
        break;
    case Token::T_SETZ:
        outputSetz(instruction);
        break;
    default:
        assert(false);
        out("// ", instruction->instructionText(), " unimplemented!");
    }

    bool hadOutput = getOutputPtr() != initialOutputPtr;
    if (hadOutput) {
        if (getOutputPtr()[-1] != '}')
            out(';');
#ifndef NDEBUG
        outputOriginalInstructionComment(instruction, initialOutputPtr - sizeof(kIndent));
#else
        out(Util::kNewLine);
#endif
        if (instruction->isBranch() && instruction->type() != Token::T_CALL)
            out(Util::kNewLine);
    } else {
        unget(kTabSize);
    }
}

void COutput::outputDataItem(const DataItem *item, const OutputItem *nextItem, bool onlyDeclare)
{
    auto numElements = item->numElements();
    bool isOffset = numElements == 1 && item->begin()->isOffset();
    bool isSprite = false;

    auto arraySize = getDataItemArraySize(item);

    if (onlyDeclare)
        out("extern ");

    char nameBuff[256];

    if (isOffset) {
        out("void *");
    } else if (!item->structName().empty()) {
        out(item->structName(), ' ');
    } else {
        if (isSpriteVar(item->name())) {
            out("Sprite ");
            isSprite = true;
        } else {
            auto typeInfo = getTypeInfo(item->size());
            out(typeInfo.unsignedType, ' ');
        }
    }

    if (item->name().empty()) {
        assert(m_dataIndex < 100'000);
        sprintf(nameBuff, "auto_%05d", m_dataIndex++);
        out(nameBuff);
    } else {
        out(item->name());
    }

    if (arraySize > 0)
        out('[', arraySize, ']');

    if (onlyDeclare) {
        out(';', Util::kNewLine);
        return;
    }

    if (numElements > 0)
        out(" = ");

    if (isOffset)
        out('&');

    if (arraySize > 0 || isSprite)
        out('{');

    auto element = item->begin();
    for (size_t i = 0; i < numElements; i++, element = element->next()) {
        bool last = i == numElements - 1;
        bool zeroTerminate = false;

        if (numElements == 2 && element->type() == DataItem::kString && !last) {
            auto next = element->next();
            if (next->isNumber() && next->value() == 0)
                zeroTerminate = true;
        }

        if (element->dup()) {
            for (size_t i = 0; i < element->dup() - 1; i++) {
                outputItem(element, false);
                out(", ");
            }
        }

        outputItem(element, zeroTerminate);

        if (isOffset && element->offset())
            out('+', element->offset());

        if (!last) {
            if (zeroTerminate) {
                assert(!element->dup());
                element = element->next();
                i++;
            } else {
                out(',');
            }
        }
    }

    if (arraySize > 0 || isSprite)
        out('}');

    out(';', Util::kNewLine);

    if (nextItem && nextItem->type() == OutputItem::kProc)
        out(Util::kNewLine);
}

void COutput::outputItem(const DataItem::Element *element, bool zeroTerminate)
{
    assert(element);
    const auto& text = element->text();

    if (element->type() == DataItem::kHex) {
        outputToken(text, Token::T_HEX);
    } else if (element->type() == DataItem::kBin) {
        outputToken(text, Token::T_BIN);
    } else if (element->type() == DataItem::kString) {
        assert(text.first() == '\'' && text.last() == '\'');

        if (zeroTerminate) {
            outputToken(text, Token::T_STRING, false);
        } else {
            for (size_t i = 1; i < text.length() - 1; i++) {
                out('\'');
                if (text[i] == '\'')
                    out("\\'");
                else if (text[i] == '\\')
                    out("\\\\");
                else
                    out(text[i]);
                out('\'');

                if (i < text.length() - 2)
                    out(", ");
            }
        }
    } else if (text == "<0>") {
        out("{0}");
    } else {
        if (element->type() == DataItem::kLabel) {
            auto dotIndex = text.indexOf('.');
            if (dotIndex >= 0 && text.contains("Sprite")) {
                // FFS IDA you're killing me
                auto field = text.substr(dotIndex + 1);

                char buf[256] = "Sprite.";
                field.copy(buf + strlen(buf));

                auto offsetHolder = m_structMap.get(buf, strlen(buf));
                assert(offsetHolder);

                assert(getOutputPtr()[-1] == '&');
                setOutputPtr(getOutputPtr() - 1);

                out("(char *)&", text.substr(0, dotIndex), '+', static_cast<int>(offsetHolder->offset()));
                return;
            }
        }
        out(text);
    }
}

void COutput::outputProc(const Proc *proc)
{
    if (m_insideProc)
        out('}', Util::kNewLine, Util::kNewLine);

    m_insideProc = true;

    out("void ", proc->name(), "()", Util::kNewLine, '{', Util::kNewLine);
}

void COutput::outputEndProc(const EndProc *endProc, const String& comment, const OutputItem *next)
{
    assert(m_insideProc);

    m_insideProc = false;
    out('}', Util::kNewLine, Util::kNewLine);
}

void COutput::outputLabel(const Label *label)
{
    if (label->name() == "return")
        return;

    if (m_insideProc) {
        if (!isLastLineEmpty())
            out(Util::kNewLine);

        outputLabel(label->name());
        out(":;");
    } else {
        out("// ", label->name());
    }

    out(Util::kNewLine);
}

void COutput::outputStackVariable(const StackVariable *var)
{
    out(kIndent, var->sizeString(), ' ', var->name(), ';', Util::kNewLine);
}

void COutput::outputMov(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    assert(!src.base.empty() && !dst.base.empty());
    assert(!src.size || !dst.size || (instruction->type() == Token::T_MOV ? dst.size == src.size : dst.size != src.size));
    assert(!(src.pointer && src.address) && !(dst.pointer && dst.address));

    outputInstructionArgument(dst, src.address, src.size);

    // I'm sowwy
    if (dst.base == "newJobOffers.teamName")
        out("[0]");

    out(" = ");

    if (instruction->type() == Token::T_MOVSX) {
        auto typeInfo = getTypeInfo(src.size);
        out('(', typeInfo.signedType, ")(");
    }

    outputInstructionArgument(src, dst.address, dst.size);

    if (instruction->type() == Token::T_MOVSX)
        out(')');
}

void COutput::outputMovs(const Instruction *instruction)
{
    out('{', Util::kNewLine);
    out(kIndent, kIndent, "int inc = g_flags.direction ? +1 : -1;", Util::kNewLine);
    out(kIndent, kIndent);

    auto type = "";

    switch (instruction->type()) {
    case Token::T_MOVSB:
        type = "byte";
        break;
    case Token::T_MOVSW:
        type = "word";
        break;
    case Token::T_MOVSD:
        type = "dword";
        break;
    default:
        assert(false);
    }

    out(type, " *src = (", type, " *)esi, *dst = (", type, " *)edi;", Util::kNewLine);

    assert(instruction->prefix() == "rep");

    if (instruction->prefix() == "rep")
        out(kIndent, kIndent, "while (ecx--)", Util::kNewLine, kIndent);

    out(kIndent, kIndent, "*(dst += inc) = *(src += inc);", Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputStos(const Instruction *instruction)
{
    out('{', Util::kNewLine);
    out(kIndent, kIndent, "int inc = g_flags.direction ? +1 : -1;", Util::kNewLine);
    out(kIndent, kIndent);

    auto type = "";
    auto reg = "";

    switch (instruction->type()) {
    case Token::T_STOSB:
        type = "byte";
        reg = "al";
        break;
    case Token::T_STOSW:
        type = "word";
        reg = "ax";
        break;
    case Token::T_STOSD:
        type = "dword";
        reg = "eax";
        break;
    default:
        assert(false);
    }

    out(type, " *dst = (", type, " *)edi;", Util::kNewLine);

    assert(instruction->prefix().empty() || instruction->prefix() == "rep");

    if (instruction->prefix() == "rep")
        out(kIndent, kIndent, "while (ecx--)", Util::kNewLine, kIndent);

    out(kIndent, kIndent, "*(dst += inc) = ", reg, ';', Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputLods(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0 && instruction->prefix().empty());

    out('{', Util::kNewLine);
    out(kIndent, kIndent, "int inc = g_flags.direction ? +1 : -1;", Util::kNewLine);
    out(kIndent, kIndent);

    auto type = "";
    auto reg = "";

    switch (instruction->type()) {
    case Token::T_LODSB:
        type = "byte";
        reg = "al";
        break;
    case Token::T_LODSW:
        type = "word";
        reg = "ax";
        break;
    case Token::T_LODS:
        type = "dword";
        reg = "eax";
        break;
    default:
        assert(false);
    }

    out(type, " *dst = (", type, " *)edi;", Util::kNewLine);

    out(kIndent, kIndent, reg, " = *(dst += inc);", Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputCall(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    const auto& operand = instruction->operands()[0];
    const auto target = operand.begin();
    const auto& text = target->text();

    if (!text.startsWith('$')) {
        assert(target->next() == operand.end());
        outputFunctionInvoke(text);
    }
}

void COutput::outputPushPop(const Instruction *instruction)
{
    assert(instruction->type() == Token::T_PUSH || instruction->type() == Token::T_POP);
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);
    const auto& op = params[0];

    out(instruction->type() == Token::T_PUSH ? "push(" : "pop(");
    outputInstructionArgument(op);
    out(')');
}

void COutput::outputCbw(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("ah = (int8_t)al < 0 ? -1 : 0");
}

void COutput::outputCwde(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("g_eax.hi16 = (int16_t)ax < 0 ? -1 : 0");
}

void COutput::outputCdq(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("edx = (int32_t)eax < 0 ? -1 : 0");
}

void COutput::outputOrXor(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);
    out(kIndent, kIndent, typeInfo.unsignedType, " res = ");

    outputInstructionArgument(dst, src.address);

    switch (instruction->type()) {
    case Token::T_OR: out(" |= "); break;
    case Token::T_XOR: out(" ^= "); break;
    default: assert(false);
    }

    outputInstructionArgument(src, dst.address, dst.size);
    out(';', Util::kNewLine);

    out(kIndent, kIndent, "g_flags.overflow = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.carry = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.sign = (res & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = res != 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputCmpSubAdd(const Instruction *instruction, bool commitResult, bool add)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)");
    outputInstructionArgument(dst, src.address);
    out(';', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " src = (", typeInfo.signedType, ')');
    outputInstructionArgument(src, dst.address, dst.size);
    out(';', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " res = *dst ", add ? '+' : '-', " src;", Util::kNewLine);

    if (commitResult)
        out(kIndent, kIndent, "*dst = res;", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.overflow = *dst < 0 ? src > *dst - ", typeInfo.signedMin,
        " : src < *dst - ", typeInfo.signedMax, ';', Util::kNewLine);
    out(kIndent, kIndent, "g_flags.carry = (", typeInfo.unsignedType, ")(*dst + src) < (", typeInfo.unsignedType, ")*dst;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.sign = res & ", typeInfo.signMask, " != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = res != 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputIncDec(const Instruction *instruction, bool increment)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)&(");
    outputInstructionArgument(op);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.overflow = (*dst)", increment ? "++" : "--", " == ",
        increment ? typeInfo.signedMax : typeInfo.signedMin, ';', Util::kNewLine);
    out(kIndent, kIndent, "g_flags.sign = *dst & ", typeInfo.signMask, " != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = *dst != 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputAndTest(const Instruction *instruction, bool commitResult)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " res = ");
    outputInstructionArgument(dst, src.address);
    out(" & ");
    outputInstructionArgument(src, dst.address, dst.size);
    out(';', Util::kNewLine);

    if (commitResult) {
        out(kIndent, kIndent);
        outputInstructionArgument(dst, src.address);
        out(" = res;", Util::kNewLine);
    }

    out(kIndent, kIndent, "g_flags.overflow = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.carry = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.sign = res & ", typeInfo.signMask, " != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = res != 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputXchg(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " *dst = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(dst, src.address);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " *src = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(src, dst.address, dst.size);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "*(", typeInfo.unsignedType, " *)&g_tmp = *dst;", Util::kNewLine);
    out(kIndent, kIndent, "*dst = *src;", Util::kNewLine);
    out(kIndent, kIndent, "*src = *(", typeInfo.unsignedType, " *)&g_tmp;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputMul(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);
    const auto& src = params[0];

    assert(src.size);
    auto typeInfo = getTypeInfo(src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " src = ");
    outputInstructionArgument(src);
    out(';', Util::kNewLine);

    switch (src.size) {
    case 1:
        out(kIndent, kIndent, "ax = al * src;", Util::kNewLine);
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = ah != 0;", Util::kNewLine);
        break;
    case 2:
        out(kIndent, kIndent, "g_tmp.all = ax * src;", Util::kNewLine);
        out(kIndent, kIndent, "ax = g_tmp.lo16;", Util::kNewLine);
        out(kIndent, kIndent, "dx = g_tmp.hi16;", Util::kNewLine);
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = dx != 0;", Util::kNewLine);
        break;
    case 4:
        out(kIndent, kIndent, "uint64_t res = eax * src;", Util::kNewLine);
        out(kIndent, kIndent, "eax = res & 0xffffffff;", Util::kNewLine);
        out(kIndent, kIndent, "edx = res >> 32;", Util::kNewLine);
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = edx != 0;", Util::kNewLine);
        break;
    default:
        assert(false);
        break;
    }

    out(kIndent, '}');
}

void COutput::outputImul(const Instruction *instruction)
{
    assert(instruction->numOperands() > 0);

    auto params = getOperandsInfo(instruction);
    const auto& dst = params[0];

    assert(dst.size);
    auto typeInfo = getTypeInfo(dst.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, ' ', instruction->numOperands() == 1 ? "src" : "dst", " = ");
    outputInstructionArgument(dst);
    out(';', Util::kNewLine);

    if (instruction->numOperands() == 1) {
        const auto& src = dst;

        switch (src.size) {
        case 1:
            out(kIndent, kIndent, "ax = (int8_t)al * src;", Util::kNewLine);
            out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = (int8_t)ax != (int8_t)al;", Util::kNewLine);
            break;
        case 2:
            out(kIndent, kIndent, "g_tmp.all = (int16_t)ax * src;", Util::kNewLine);
            out(kIndent, kIndent, "ax = (int16_t)g_tmp.lo16;", Util::kNewLine);
            out(kIndent, kIndent, "dx = (int16_t)g_tmp.hi16;", Util::kNewLine);
            out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = (int32_t)g_tmp.all != (int16_t)ax;", Util::kNewLine);
            break;
        case 4:
            out(kIndent, kIndent, "int64_t res = eax * src;", Util::kNewLine);
            out(kIndent, kIndent, "eax = res & 0xffffffff;", Util::kNewLine);
            out(kIndent, kIndent, "edx = res >> 32;", Util::kNewLine);
            out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = res != (int32_t)eax;", Util::kNewLine);
            break;
        default:
            assert(false);
            break;
        }
    } else {
        const auto& src = params[1];

        assert(dst.size == src.size && (dst.size == 2 || dst.size == 4));

        out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)&(");
        outputInstructionArgument(dst, src.address);
        out(");", Util::kNewLine);

        out(kIndent, kIndent, typeInfo.signedType, " src = ");
        outputInstructionArgument(src);
        out(';', Util::kNewLine);

        if (instruction->numOperands() == 3) {
            out(kIndent, kIndent, typeInfo.nextLargerSignedType, " tmp = *dst * src;");
        } else {
            assert(instruction->numOperands() == 3);

            const auto& src2 = params[2];

            out(kIndent, kIndent, typeInfo.signedType, " src2 = ");
            outputInstructionArgument(src2);
            out(';', Util::kNewLine);

            out(kIndent, kIndent, typeInfo.nextLargerSignedType, " tmp = src * src2;");
        }

        out(kIndent, kIndent, "*dst = tmp;");
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = *dst != tmp;");
    }

    out(kIndent, '}');
}

void COutput::outputDiv(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);
    const auto& src = params[0];

    assert(src.size);
    auto typeInfo = getTypeInfo(src.size);

    out('{', Util::kNewLine);

    bool signedDiv = instruction->type() == Token::T_IDIV;
    auto type = signedDiv ? typeInfo.signedType : typeInfo.unsignedType;

    out(kIndent, kIndent, type, " src = ");
    if (signedDiv)
        out('(', type, ')');
    outputInstructionArgument(src);
    out(';', Util::kNewLine);

    // we will ignore overflow and division by zero
    switch (src.size) {
    case 1:
        if (signedDiv) {
            out(kIndent, kIndent, "int8_t quot = (int16_t)ax / src;", Util::kNewLine);
            out(kIndent, kIndent, "int8_t rem = (int16_t)ax % src;", Util::kNewLine);
        } else {
            out(kIndent, kIndent, "byte quot = ax / src;", Util::kNewLine);
            out(kIndent, kIndent, "byte rem = ax % src;", Util::kNewLine);
        }

        out(kIndent, kIndent, "al = quot;", Util::kNewLine);
        out(kIndent, kIndent, "ah = rem;", Util::kNewLine);
        break;
    case 2:
        if (signedDiv) {
            out(kIndent, kIndent, "int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;", Util::kNewLine);
            out(kIndent, kIndent, "int16_t quot = dividend / src;", Util::kNewLine);
            out(kIndent, kIndent, "int16_t rem = dividend % src;", Util::kNewLine);
        } else {
            out(kIndent, kIndent, "dword dividend = (dx << 16) | ax;", Util::kNewLine);
            out(kIndent, kIndent, "word quot = dividend / src;", Util::kNewLine);
            out(kIndent, kIndent, "word rem = dividend % src;", Util::kNewLine);
        }

        out(kIndent, kIndent, "ax = quot;", Util::kNewLine);
        out(kIndent, kIndent, "dx = rem;", Util::kNewLine);
        break;
    case 4:
        if (signedDiv) {
            out(kIndent, kIndent, "int64_t dividend = ((int64_t)edx << 32) | (int32_t)eax;", Util::kNewLine);
            out(kIndent, kIndent, "int32_t quot = dividend / src;", Util::kNewLine);
            out(kIndent, kIndent, "int32_t rem = dividend % src;", Util::kNewLine);
        } else {
            out(kIndent, kIndent, "uint64_t dividend = ((uint64_t)edx << 32) | eax;", Util::kNewLine);
            out(kIndent, kIndent, "dword quot = dividend / src;", Util::kNewLine);
            out(kIndent, kIndent, "dword rem = dividend % src;", Util::kNewLine);
        }

        out(kIndent, kIndent, "eax = quot;", Util::kNewLine);
        out(kIndent, kIndent, "edx = rem;", Util::kNewLine);
        break;
    default:
        assert(false);
        break;
    }

    out(kIndent, '}');
}

void COutput::outputShift(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& shiftCount = params[1];

    assert(dst.size);
    bool signedShift = instruction->type() == Token::T_SAR;
    auto typeInfo = getTypeInfo(dst.size);
    auto type = signedShift ? typeInfo.signedType : typeInfo.unsignedType;

    out('{', Util::kNewLine);

    out(kIndent, kIndent, type, " *dst = (", type, " *)&(");
    outputInstructionArgument(dst, shiftCount.address);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "dword shiftCount = (");
    outputInstructionArgument(shiftCount, dst.address, dst.size);
    out(") & 0x1f; ", Util::kNewLine);

    out(kIndent, kIndent, "if (shiftCount) {", Util::kNewLine);
    out(kIndent, kIndent, kIndent, type, " res = *dst ");

    switch (instruction->type()) {
    case Token::T_SHL:
        out("<<");
        break;
    case Token::T_SHR:
    case Token::T_SAR:
        out(">>");
        break;
    default:
        assert(false);
        break;
    }

    out(" shiftCount;", Util::kNewLine);

    out(kIndent, kIndent, kIndent, "if (shiftCount <= ", typeInfo.bitCount, ')', Util::kNewLine);
    out(kIndent, kIndent, kIndent, kIndent, "g_flags.carry = (*dst >> (", typeInfo.bitCount, " - shiftCount)) & 1;", Util::kNewLine);
    out(kIndent, kIndent, kIndent, "else", Util::kNewLine);
    out(kIndent, kIndent, kIndent, kIndent, "g_flags.carry = 0;", Util::kNewLine);
    out(kIndent, kIndent, kIndent, "if (shiftCount == 1)", Util::kNewLine);
    out(kIndent, kIndent, kIndent, kIndent, "g_flags.overflow = ((*dst >> ", typeInfo.bitCount - 1, ") & 1)");
    if (instruction->type() == Token::T_SHL)
        out(" ^ ((*dst >> ", typeInfo.bitCount - 2, ") & 1)");
    out(';', Util::kNewLine);
    out(kIndent, kIndent, kIndent, "g_flags.sign = (res & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, kIndent, "g_flags.zero = res != 0;", Util::kNewLine);

    out(kIndent, kIndent, kIndent, "*dst = res;", Util::kNewLine);

    out(kIndent, kIndent, '}', Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputRotate(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& rotationCount = params[1];

    assert(dst.size);
    auto typeInfo = getTypeInfo(dst.size);

    out('{', Util::kNewLine);

    bool carryRotation = instruction->type() == Token::T_RCL || instruction->type() == Token::T_RCR;
    int mod = dst.size * 8 + (carryRotation != 0);

    out(kIndent, kIndent, typeInfo.unsignedType, " *dst = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(dst, rotationCount.address);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "dword rotationCount = ((");
    outputInstructionArgument(rotationCount, dst.address, dst.size);
    out(") & 0x1f) % ", mod, ';', Util::kNewLine);

    out(kIndent, kIndent, "if (rotationCount) {", Util::kNewLine);

    switch (instruction->type()) {
    case Token::T_RCL:
    case Token::T_ROL:
        out(kIndent, kIndent, kIndent, "dword newCarry = (*dst >> (", typeInfo.bitCount, " - rotationCount)) & 1;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "*dst = (*dst << rotationCount) | (*dst >> (", typeInfo.bitCount, " - rotationCount");
            if (instruction->type() == Token::T_RCL)
                out(" + 1) << 1) | g_flags.carry;", Util::kNewLine);
            else
                out("));", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "g_flags.carry = newCarry;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "if (rotationCount == 1)", Util::kNewLine);
        out(kIndent, kIndent, kIndent, kIndent, "g_flags.overflow = ((*dst & ", typeInfo.signMask, ") != 0) ^ g_flags.carry;", Util::kNewLine);
        break;
    case Token::T_RCR:
    case Token::T_ROR:
        out(kIndent, kIndent, kIndent, "if (rotationCount == 1)", Util::kNewLine);
        out(kIndent, kIndent, kIndent, kIndent, "g_flags.overflow = ((*dst & ", typeInfo.signMask, ") != 0) ^ g_flags.carry;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "int newCarry = (*dst >> (rotationCount - 1)) & 1;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "*dst = (*dst >> rotationCount) | ");
        if (instruction->type() == Token::T_RCR) {
            out("(g_flags.carry << (", typeInfo.bitCount, " - rotationCount)) | ((*dst >> 1) << (",
                typeInfo.bitCount, " - rotationCount + 1));", Util::kNewLine);
        } else {
            out("(*dst << (", typeInfo.bitCount, " - rotationCount));", Util::kNewLine);
        }
        out(kIndent, kIndent, kIndent, "g_flags.carry = newCarry;", Util::kNewLine);
        break;
    default:
        assert(false);
    }

    out(kIndent, kIndent, "}", Util::kNewLine);
    out(kIndent, "}");
}

void COutput::outputIntInOut(const Instruction *instruction)
{
    // TODO: implement debug break in place of int 3
    out("(void)0");
}

void COutput::outputNeg(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)&(");
    outputInstructionArgument(op);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.carry = *dst != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.overflow = *dst == ", typeInfo.signedMin, ';', Util::kNewLine);

    out(kIndent, kIndent, "*dst = -*dst;", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.sign = *dst & ", typeInfo.signMask, " != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = *dst != 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputNot(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " *dst = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(op);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "*dst = ~*dst;", Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputLoop(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);
    assert(instruction->prefix().empty());

    outputConditionalJump(instruction, "--ecx");
}

void COutput::outputPushf(const Instruction *instruction)
{
    out("g_stack[--g_stackTop] = g_flags.carry | (g_flags.zero << 6) | (g_flags.sign << 7) | "
        "(g_flags.direction << 10) | (g_flags.overflow << 11)");
}

void COutput::outputPopf(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("pop(g_tmp.all);", Util::kNewLine);
    out(kIndent, "g_flags.carry = g_tmp.all & 1;", Util::kNewLine);
    out(kIndent, "g_flags.zero = (g_tmp.all >> 6) & 1;", Util::kNewLine);
    out(kIndent, "g_flags.sign = (g_tmp.all >> 7) & 1;", Util::kNewLine);
    out(kIndent, "g_flags.direction = (g_tmp.all >> 10) & 1;", Util::kNewLine);
    out(kIndent, "g_flags.overflow = (g_tmp.all >> 11) & 1");
}

void COutput::outputPusha(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("g_tmp.all = g_stackTop;", Util::kNewLine);
    out(kIndent, "push(eax);", Util::kNewLine);
    out(kIndent, "push(ecx);", Util::kNewLine);
    out(kIndent, "push(edx);", Util::kNewLine);
    out(kIndent, "push(ebx);", Util::kNewLine);
    out(kIndent, "push(g_tmp.all);", Util::kNewLine);
    out(kIndent, "push(ebp);", Util::kNewLine);
    out(kIndent, "push(esi);", Util::kNewLine);
    out(kIndent, "push(edi)");
}

void COutput::outputPopa(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("pop(edi);", Util::kNewLine);
    out(kIndent, "pop(esi);", Util::kNewLine);
    out(kIndent, "pop(ebp);", Util::kNewLine);
    out(kIndent, "g_stackTop++;", Util::kNewLine);
    out(kIndent, "pop(ebx);", Util::kNewLine);
    out(kIndent, "pop(edx);", Util::kNewLine);
    out(kIndent, "pop(ecx);", Util::kNewLine);
    out(kIndent, "pop(eax)");
}

void COutput::outputStc(const Instruction *instruction)
{
    out("g_flags.carry = true");
}

void COutput::outputClc(const Instruction *instruction)
{
    out("g_flags.carry = false");
}

void COutput::outputCld(const Instruction *instruction)
{
    out("g_flags.direction = false");
}

void COutput::outputSetz(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    outputInstructionArgument(op);
    out(" = g_flags.zero != 0");
}

void COutput::outputConditionalJump(const Instruction *instruction, const char *condition /* = nullptr */)
{
    assert(instruction && instruction->isBranch() && instruction->numOperands() == 1);

    auto target = instruction->operands()[0].begin();

    if (target->type() == Token::T_SHORT)
        target = target->next();

    if (!target->text().startsWith('$')) {
        assert(target->next() == instruction->operands()[0].end());

        const auto& label = target->text();
        bool localLabel = label.startsWith('@');

        if (condition)
            out("if (", condition, ")", Util::kNewLine, kIndent, kIndent);

        if (localLabel || m_inProcLabels.present(target->text())) {
            if (target->text() == "return") {
                out("return;");
            } else {
                out("goto ");
                outputLabel(label);
            }
        } else {
            out("{ ");
            outputFunctionInvoke(label);
            out("; return; }");
        }
    }
}

void COutput::outputJmp(const Instruction *instruction)
{
//last jmp -> call + don't add extra new line
    outputConditionalJump(instruction);
}

void COutput::outputJg(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.zero && g_flags.sign == g_flags.overflow");
}

void COutput::outputJge(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.sign == g_flags.overflow");
}

void COutput::outputJl(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.sign != g_flags.overflow");
}

void COutput::outputJz(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.zero");
}

void COutput::outputJnz(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.zero");
}

void COutput::outputJs(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.sign");
}

void COutput::outputJns(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.sign");
}

void COutput::outputJb(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.carry");
}

void COutput::outputJa(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.carry && !g_flags.zero");
}

void COutput::outputJnb(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.carry");
}

void COutput::outputJbe(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.carry || g_flags.zero");
}

void COutput::outputJle(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.zero || g_flags.sign != g_flags.overflow");
}

void COutput::outputJo(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.overflow");
}

void COutput::outputJno(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.overflow");
}

// A hack for handling dynamic jump into a table of labels which are inside a proc, and tied within this proc
// (they jump into one another); there is no portable way to store goto label in table, and later jump to it.
auto COutput::checkForSwitchTable(OutputIterator it, const Instruction *instruction) -> OutputIterator
{
    if (instruction->type() == Token::T_MOV) {
        auto isOffset = instruction->operands()[1].begin()->type() == Token::T_OFFSET;
        if (isOffset) {
            auto address = instruction->operands()[1].begin()->next();
            assert(address != instruction->operands()[1].end());

            if (address->text() == kSwitchTableName) {
                while (it->next() != m_outputItems.end()) {
                    it = it->next();
                    if (it->type() == OutputItem::kInstruction) {
                        auto instruction = it->getItem<Instruction>();
                        if (instruction->type() == Token::T_JMP)
                            break;
                    }
                }

                out(kIndent, "switch (D0) {", Util::kNewLine);
                out(kIndent, "case 0: goto nextEntry;", Util::kNewLine);
                out(kIndent, "case 1: goto invisibleItem;", Util::kNewLine);
                out(kIndent, "case 2: goto setPositions;", Util::kNewLine);
                out(kIndent, "case 3: goto func1;", Util::kNewLine);
                out(kIndent, "case 4: goto entryFrame;", Util::kNewLine);
                out(kIndent, "case 5: goto sprite1;", Util::kNewLine);
                out(kIndent, "case 6: goto invalidType;", Util::kNewLine);
                out(kIndent, "case 7: goto func2;", Util::kNewLine);
                out(kIndent, "case 8: goto stringEntry;", Util::kNewLine);
                out(kIndent, "case 9: goto sprite2;", Util::kNewLine);
                out(kIndent, "case 10: goto stringTable;", Util::kNewLine);
                out(kIndent, "case 11: goto multiLineText;", Util::kNewLine);
                out(kIndent, "case 12: goto number;", Util::kNewLine);
                out(kIndent, "case 13: goto onSelectFireOnly;", Util::kNewLine);
                out(kIndent, "case 14: goto onSelect;", Util::kNewLine);
                out(kIndent, "case 15: goto beforeDrawFunc;", Util::kNewLine);
                out(kIndent, "case 16: goto afterDrawFunc;", Util::kNewLine);
                out(kIndent, "case 17: goto leftSkip;", Util::kNewLine);
                out(kIndent, "case 18: goto rightSkip;", Util::kNewLine);
                out(kIndent, "case 19: goto upSkip;", Util::kNewLine);
                out(kIndent, "case 20: goto downSkip;", Util::kNewLine);
                out(kIndent, "case 21: goto spriteCopy;", Util::kNewLine);
                out(kIndent, '}', Util::kNewLine);
            }
        }
    }

    return it;
}

// Remove switch table from data stream, it will be hard-coded into the code.
auto COutput::checkForSwitchTable(OutputIterator it, const DataItem *dataItem) -> OutputIterator
{
    if (dataItem->name() == kSwitchTableName)
        while (it != m_outputItems.end() && it->next()->type() == OutputItem::kDataItem)
            ++it;

    return it;
}

void COutput::fillStructInfo()
{
    for (const auto& struc : m_structs) {
        char buf[256];
        struc.name().copy(buf);
        buf[struc.name().length()] = '.';

        size_t offset = 0;

        for (const auto& field : struc) {
            auto nameLen = struc.name().length() + field.name().length() + 1;
            assert(nameLen < sizeof(buf));

            field.name().copy(buf + struc.name().length() + 1);

            if (field.byteSize()) {
                m_structMap.add<size_t, size_t>(buf, nameLen, offset, field.byteSize());
                offset += field.byteSize();
            } else {
                auto nestedStruct = m_structs.findStruct(field.type());
                assert(nestedStruct);

                buf[nameLen++] = '.';
                size_t nestedStructOffset = 0;

                for (const auto& field : *nestedStruct) {
                    assert(nameLen + field.name().length() < sizeof(buf));

                    field.name().copy(buf + nameLen);
                    m_structMap.add<size_t, size_t>(buf, nameLen + field.name().length(),
                        offset + nestedStructOffset, field.byteSize());

                    nestedStructOffset += field.byteSize();
                }

                m_structMap.add<size_t, size_t>(buf, nameLen - 1, offset, nestedStructOffset);
                offset += nestedStructOffset;
            }
        }

        m_structMap.add(struc.name(), offset, offset);
    }

    m_structMap.seal();
}

bool COutput::isFinalRetn(const OutputItem& item)
{
    assert(item.type() == OutputItem::kInstruction && item.next() != m_outputItems.end());

    auto instruction = item.getItem<Instruction>();
    auto nextType = item.next()->type();

    return instruction->type() == Token::T_RETN &&
        (nextType == OutputItem::kEndProc || nextType == OutputItem::kProc || nextType == OutputItem::kDirective);
}

bool COutput::isLastLineEmpty() const
{
    auto doubleNewLineLen = 2 * Util::kNewLine.size();
    if (outputLength() < doubleNewLineLen)
        return false;

    return !memcmp(getOutputPtr() - doubleNewLineLen, Util::kNewLine.data(), Util::kNewLine.size())
        && !memcmp(getOutputPtr() - 2 * doubleNewLineLen, Util::kNewLine.data(), Util::kNewLine.size());
}

void COutput::outputOriginalInstructionComment(const Instruction *instruction, const char *start)
{
    addCommentPadding(start);

    auto prefixSpace = !instruction->prefix().empty() ? " " : "";
    out("// ", instruction->prefix(), prefixSpace, instruction->instructionText());
    if (instruction->hasOperands())
        out(' ');

    for (size_t i = 0; i < instruction->numOperands(); i++) {
        const auto& operand = instruction->operands()[i];
        const String *prev = nullptr;

        for (const auto& it : operand) {
            if (prev && Util::isId(prev->last()) && Util::isId(it.text().first()))
                out(' ');

            out(it.text());

            prev = &it.text();
        }

        if (getOutputPtr()[-1] == ' ')
            unget(1);

        if (i != instruction->numOperands() - 1)
            out(", ");
    }

    out(Util::kNewLine);
}

void COutput::addCommentPadding(const char *start)
{
    constexpr int kCommentOffset = 44;

    auto lineLength = getLineLength(start);
    int fillLength = kCommentOffset - lineLength;

    // always output at least one space between semi-colon and comment
    do {
        out(' ');
    } while (--fillLength > 0);
}

size_t COutput::getLineLength(const char *start)
{
    auto end = getOutputPtr();

    for (auto p = end - 1; p >= start; p--) {
        if (*p == '\n') {
            start = p + 1;
            break;
        }
    }

    return end - start;
}

void COutput::outputComment(const String& comment, bool endWithNewLine /* = true */)
{
    for (size_t i = 0; i < comment.length(); i++) {
        if (comment[i] == ';')
            out("//");
        else
            out(comment[i]);
    }

    if (endWithNewLine)
        out(Util::kNewLine);
}

void COutput::outputFunctionInvoke(const String& target)
{
    auto isCallReg = [&]() {
        static const char *kRegs[] = { "ax", "bx", "cx", "dx", "si", "di", "bp" };

        if (target.length() != 3 || !target.startsWith('e'))
            return false;

        return std::find_if(std::begin(kRegs), std::end(kRegs), [&](const char *suffix) {
            return target[1] == suffix[0] && target[2] == suffix[1];
        }) != std::end(kRegs);
    };

    auto regIndex = amigaRegisterToIndex(target);
    if (regIndex >= 0 || isCallReg() || target.endsWith("Function"))
        out("((void (*)())(", target, "))()");
    else
        out(target, "()");
}

size_t COutput::getDataItemArraySize(const DataItem *item)
{
    assert(item->numElements() > 0);

    size_t size = 0;
    auto element = item->begin();

    if (item->numElements() > 1 || element->type() == DataItem::kString) {
        for (size_t i = 0; i < item->numElements(); i++, element = element->next()) {
            assert(i == 0 || !(element->type() & DataItem::kIsOffsetFlag));

            if (element->type() == DataItem::kString)
                size += element->text().length() - 2;
            else
                size += element->dup() ? element->dup() : 1;
        }
    } else if (element->dup()) {
        size = element->dup();
    }

    return size;
}

void COutput::ensureFunction()
{
    if (!m_insideProc) {
        char buf[256];
        sprintf_s(buf, "void autoProc_%03d()", m_autoGeneratedProcIndex++);
        out(buf, Util::kNewLine, '{', Util::kNewLine);
        m_insideProc = true;
    }
}

void COutput::outputInstructionArgument(const OperandInfo& op, bool assignAddress /* = false */, size_t defaultSize /* = 0 */)
{
    bool gotOffset = !op.offset.empty();

    if (op.pointer || gotOffset) {
        if (assignAddress || op.address) {
            out("*(void **)");
        } else {
            out('*');

            auto size = op.size;
            if (!size)
                size = defaultSize;
            if (!size)
                size = 4;   // assume 32-bit if no size given

            if (size != 1) {
                auto sizeSpecifier = getTypeInfo(size).unsignedType;
                out('(', sizeSpecifier, " *)");
            }
        }
    } else if (assignAddress) {
        out("(void *)");
    }

    if (op.pointer || op.address || gotOffset) {
        if (gotOffset)
            out("((byte *)");

        if (op.pointer || op.address)
            out('&');
    }

    outputToken(op.base, op.baseType);

    if (!op.offset.empty()) {
        out(" + ");
        outputToken(op.offset, op.offsetType);
    }

    if (!op.scale.empty())
        out(" * ", op.scale);

    if (!op.displacement.empty()) {
        out(" + ");
        outputToken(op.displacement, op.displacementType);
    }

    if (gotOffset)
        out(')');
}

void COutput::outputToken(const String& op, Token::Type type, bool isInstruction /* = true */)
{
    int startOffset = 0;

    switch (type) {
    case Token::T_HEX:
        if (op.startsWith('-')) {
            out('-');
            startOffset = 1;
        }
        out("0x", op.substr(startOffset).withoutLast());
        break;

    case Token::T_BIN:
        {
            int num = 0;

            for (size_t i = 0; i < op.length() - 1; i++)
                num = num * 2 + op[i] - '0';

            out(num);
        }
        break;

    case Token::T_STRING:
        if (isInstruction) {
            out(op);
        } else {
            out('"');
            for (size_t i = 1; i < op.length() - 1; i++) {
                if (op[i] == '\\')
                    out('\\');
                out(op[i]);
            }
            out('"');
        }
        break;

    default:
        out(op);
        break;
    }
}

void COutput::outputLabel(const String& label)
{
    if (label.startsWith("@@"))
        out("__", label.substr(2));
    else
        out(label);
}

auto COutput::getOperandsInfo(const Instruction *instruction) const -> InstructionOperandsInfo
{
    InstructionOperandsInfo result;
    static thread_local char convBuf[3][4];

    for (size_t i = 0; i < instruction->numOperands(); i++) {
        auto& opInfo = result[i];
        opInfo.size = instruction->operandSizes()[i];

        const auto& param = instruction->operands()[i];

        for (auto op = param.begin(); op != param.end(); op = op->next()) {
            assert(op < param.end());
            auto type = op->type();

            switch (type) {
            case Token::T_OFFSET:
                opInfo.address = true;
                assert(opInfo.base.empty());
                break;
            case Token::T_LBRACKET:
            case Token::T_BYTE:
            case Token::T_WORD:
            case Token::T_DWORD:
                opInfo.pointer = true;
                break;
            case Token::T_PTR:
            case Token::T_RBRACKET:
            case Token::T_LPAREN:
            case Token::T_RPAREN:
            case Token::T_PLUS:
                // skip over
                break;
            case Token::T_MULT:
                op = op->next();

                if (opInfo.scale.empty()) {
                    opInfo.scale = op->text();
                } else {
                    // only one special case
                    static thread_local char buf[128];
                    opInfo.scale.copy(buf);
                    memcpy(buf + opInfo.scale.length(), " * ", 3);
                    op->text().copy(buf + opInfo.scale.length() + 3);

                    opInfo.scale = String(buf, opInfo.scale.length() + 3 + op->text().length());
                }

                assert(op->type() == Token::T_NUM);
                assert(op->next() == param.end() || op->next()->type() != Token::T_PLUS);
                break;
            default:
                bool forceSearch = false;
                if (type == Token::T_SIZE) {
                    op = op->next();
                    assert(op->type() == Token::T_ID);
                    forceSearch = true;
                    type = Token::T_ID;
                }
                if (type == Token::T_ID || type == Token::T_STRING || op->isRegister() || op->isNumber()) {
                    if (opInfo.base.empty()) {
                        opInfo.base = expandStructField(op, opInfo, convBuf[i], forceSearch);
                        opInfo.baseType = type;
                    } else if (opInfo.offset.empty()) {
                        opInfo.offset = expandStructField(op, opInfo, convBuf[i], forceSearch);
                        opInfo.offsetType = type;
                    } else if (opInfo.displacement.empty()) {
                        opInfo.displacement = expandStructField(op, opInfo, convBuf[i], forceSearch);
                        opInfo.displacementType = type;
                    } else {
                        assert(false);
                    }
                }
                break;
            }
        }
    }

    ensureSizeInformation(instruction, result);

    assert(result[0].size | result[1].size | result[2].size);
    assert(instruction->type() == Token::T_MOVZX || instruction->type() == Token::T_SHL || instruction->type() == Token::T_RCR ||
        instruction->type() == Token::T_RCL || instruction->type() == Token::T_ROL || instruction->type() == Token::T_ROR ||
        instruction->type() == Token::T_SAR ||
        std::accumulate(result.begin(), result.end(), 0, [](int sum, const auto& op) { return sum + op.size; }) %
        std::count_if(result.begin(), result.end(), [](const auto& op) { return op.size > 0; }) == 0);

    // fix for local variable access
    if (result[1].base == "esp") {
        if (result[1].offsetType == Token::T_ID)
            result[1].base = result[1].offset;
        else if (result[1].displacementType == Token::T_ID)
            result[1].base = result[1].displacement;
        else
            assert(false);

        result[1].offset.clear();
        result[1].displacement.clear();
    }

    return result;
}

void COutput::ensureSizeInformation(const Instruction *instruction, InstructionOperandsInfo& opInfo) const
{
    assert(!instruction->isShiftRotate() || instruction->numOperands() == 2);

    auto numKnownSizeOperands = std::count_if(opInfo.begin(), opInfo.end(), [](const auto& op) {
        return op.size > 0;
    });

    bool doThoroughSearch = instruction->isShiftRotate() && !opInfo.begin()->size || numKnownSizeOperands == 0;

    // only do more thorough search if simpler methods failed
    if (doThoroughSearch) {
        for (auto& op : opInfo) {
            if (op.baseType == Token::T_ID) {
                auto regIndex = amigaRegisterToIndex(op.base);
                if (regIndex >= 0) {
                    op.size = 4;
                    break;
                } else {
                    auto id = op.base;

                    auto dotIndex = op.base.indexOf('.');
                    if (dotIndex >= 0)
                        id = id.substr(0, dotIndex);

                    auto type = m_references.getType(id);
                    switch (type.first) {
                    case References::kByte:
                        op.size = 1;
                        return;
                    case References::kWord:
                        op.size = 2;
                        return;
                    case References::kDword:
                        op.size = 4;
                        return;
                    case References::kTbyte:
                        op.size = 10;
                        return;
                    case References::kUser:
                        {
                            assert(dotIndex >= 0);

                            auto fieldName = op.base.substr(dotIndex + 1);
                            op.size = getStructVariableSize(type.second, fieldName);
                            return;
                        }
                    default:
                        assert(false);
                    }
                }
            }
        }
    }
}

size_t COutput::getStructVariableSize(const String& structName, const String& fieldName) const
{
    assert(!structName.empty() && !fieldName.empty());

    char structNameAndField[256];
    assert(structName.length() + fieldName.length() + 1 < sizeof(structNameAndField));

    structName.copy(structNameAndField);
    structNameAndField[structName.length()] = '.';
    fieldName.copy(structNameAndField + structName.length() + 1);

    size_t len = structName.length() + fieldName.length() + 1;
    auto offsetAndSize = m_structMap.get(structNameAndField, len);

    assert(offsetAndSize);
    return offsetAndSize->size();
}

String COutput::expandStructField(Iterator::Iterator<const Instruction::Operand>& op,
    OperandInfo& opInfo, char *dest, bool forceSearch /* = false */) const
{
    if (op->type() == Token::T_ID && (forceSearch || op->text().contains('.'))) {
        if (auto field = m_structMap.get(op->text())) {
            if (!opInfo.size && opInfo.pointer)
                opInfo.size = field->size();

            auto offset = field->offset();

            if (op->next()->type() == Token::T_PLUS) {
                op = op->next()->next();
                assert(op->isNumber());
                offset += op->text().toInt();
            }

            static thread_local char numBuf[3][4];
            _itoa(offset, dest, 10);

            return { dest, strlen(dest) };
        }
    } else if (op->text().length() > 3 && op->text()[2] == ':' && op->text()[1] == 's') {
        return op->text().substr(3);
    }

    return op->text();
}

bool COutput::isSpriteVar(const String& str)
{
    return std::binary_search(m_spriteStructVars.begin(), m_spriteStructVars.end(), str);
}

auto COutput::getTypeInfo(size_t size) -> TypeInfo
{
    size = size ? size : 4;

    switch (size) {
    case 1: return { "byte", "int8_t", "int16_t", 8, "0x80", "INT8_MIN", "INT8_MAX" };
    case 2: return { "word", "int16_t", "int32_t", 16, "0x8000", "INT16_MIN", "INT16_MAX" };
    case 4: return { "dword", "int32_t", "int64_t", 32, "0x80000000", "INT32_MIN", "INT32_MAX" };
    case 8: return { "uint64_t", "int64_t", nullptr, 64, "0x8000000000000000", "INT64_MIN", "INT64_MAX" };
    default: assert(false); return {};
    };
}
