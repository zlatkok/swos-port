// Two's complement integer representation is assumed.

#include "COutput.h"
#include "COutput.h"

#define kVmHeaderFilename           "vm.h"
#define kAutoGeneratedWarning       "// " kAutoGeneratedWarningText "\n\n"

#define kAutoVarPrefix              "auto_"
#define kTableTypeStem              "ContiguousVarsTable"
#define kTableVarStem               "g_table"

#define kVmStackSize                "1024"

constexpr int kAverageBytesPerStruct = 750;
constexpr int kInProcLabelsCapacity = 30'000;
constexpr int kMaxAutoGeneratedItems = 100'000;

constexpr int kMaxTables = 32;
constexpr auto kDefsFilename = "defs.h";
constexpr auto kSwitchTableName = "menuTypesJumpTable";

COutput::COutput(const char *path, int index, const SymbolFileParser& symFileParser, const StructStream& structs, const DefinesMap& defines,
    const References& references, const OutputItemStream& outputItems)
:
    OutputWriter(path, symFileParser, structs, defines, references, outputItems), m_index(index),
    m_structMap(structs.count() * kAverageBytesPerStruct), m_inProcLabels(kInProcLabelsCapacity)
{
    fillStructInfo();
}

void COutput::setCImportSymbols(const StringList *syms)
{
    m_cImportSymbols = syms;
}

void COutput::setCExportSymbols(const StringList *syms)
{
    m_cExportSymbols = syms;
}

bool COutput::output(OutputFlags flags, CToken *openingSegment /* = nullptr */)
{
    // we'll need a bigger output buffer to accommodate large number of C statements per line
    int size = 4 * (m_structs.size() + m_defines.size() + m_outputItems.size());

    if (!openOutputFile(flags, size))
        return false;

    if (!flags)
        return true;

    out("// " kAutoGeneratedWarningText, Util::kDoubleNewLine);

    bool isDefineFile = flags & (kStructs | kDefines) && !(flags & kFullDisasembly);
    if (isDefineFile) {
        if (!outputVmFiles()) {
            closeOutputFile();
            return false;
        }
        out("#pragma once", Util::kDoubleNewLine);
    } else {
        out("#include \"" kVmHeaderFilename, '"', Util::kNewLine);
        out("#include \"", getDefsFilename(), '"', Util::kDoubleNewLine);
        out("#pragma pack(push, 1)", Util::kDoubleNewLine);
    }

    // init before processing the externs
    if (!isDefineFile)
        initTableVariables();

    bool result = true;
    if ((flags & kExterns) && !outputExterns())
        result = false;

    // we'll make everything public, so no need to output publics explicitly as in assembly

    // make sure to output this after the externs, so that the macro for string pool variables doesn't affect them
    // we'll end up with unused externs but that's fine, probably best we can do since we don't know which externs
    // are string pool table variables in all files except the one that actually holds those variables
    if (!isDefineFile)
        out("#include \"", Util::kTablesHeaderName, '"', Util::kNewLine);

    if (flags & kStructs)
        outputStructs();

    if (flags & kDefines)
        outputDefines();

    if (flags & kDisassembly) {
        outputCodeAndData();
        outputTableStructs();
        out("#pragma pack(pop)", Util::kNewLine);
    }

    if (!save())
        result = false;

    closeOutputFile();

    return result;
}

const char *COutput::getDefsFilename() const
{
    return kDefsFilename;
}

std::pair<const char *, size_t> COutput::getContiguousVariablesStructData()
{
    resetOutputPtr();
    auto start = getOutputPtr();

    for (size_t i = 0; i < m_tableVarRanges.size(); i++) {
        const auto& range = m_tableVarRanges[i];
        auto tableIndex = getGlobalTableIndex(i);

        out(Util::kNewLine, "struct " kTableTypeStem, tableIndex, Util::kNewLine, '{', Util::kNewLine);

        resetAutoDataIndex();

        std::vector<std::tuple<String, String, size_t, size_t>> cppDefines;

        for (auto item = range.first; item <= range.second; item = item->next()) {
            if (item->type() == OutputItem::kDataItem) {
                auto dataItem = item->getItem<DataItem>();
                const auto& exportedType = m_symFileParser.exportedType(dataItem->name());
                if (!std::get<0>(exportedType).empty())
                    cppDefines.push_back(std::tuple_cat(std::make_tuple(dataItem->name()), exportedType));

                out(kIndent);
                item = outputDataItem(item, kDeclare);
            }
        }

        out("};", Util::kNewLine);
        out("typedef struct " kTableTypeStem, tableIndex, " " kTableTypeStem, tableIndex, ';', Util::kDoubleNewLine);

        out("extern", Util::kNewLine);
        out("#ifdef __cplusplus", Util::kNewLine, "\"C\"", Util::kNewLine);
        out("#endif", Util::kNewLine);

        out(kTableTypeStem, tableIndex, " " kTableVarStem, tableIndex, ';', Util::kDoubleNewLine);

        out("#ifndef __cplusplus", Util::kNewLine);
        for (auto item = range.first; item <= range.second; item = item->next()) {
            auto dataItem = item->getItem<DataItem>();
            if (!dataItem->name().empty())
                out("# define ", dataItem->name(), " " kTableVarStem, tableIndex, '.', dataItem->name(), Util::kNewLine);
        }

        outputStructVarCppDefines(cppDefines, tableIndex);
        out("#endif", Util::kNewLine);
    }

    auto end = getOutputPtr();

    return { start, end - start };
}

bool COutput::outputFile(const char *filename, const char *contents, size_t size, const char *mode /* = "wb" */)
{
    const auto& outputBasePath = getOutputBaseDir();
    const auto& vmFilePath = Util::joinPaths(outputBasePath, filename);

    auto f = fopen(vmFilePath.c_str(), mode);
    if (!f)
        return false;

    auto result = fwrite(contents, size, 1, f) == 1;

    fclose(f);
    return result;
}

bool COutput::outputVmFiles()
{
    constexpr char kVmCFilename[] = "vm.c";
    constexpr char kVmHeaderContents[] =
        kAutoGeneratedWarning
        "#pragma once\n\n"

        "#ifndef __cplusplus\n\n"

        "# include <stdlib.h>\n"
        "# include <stdint.h>\n\n"

        "#define false 0\n"
        "#define true 1\n\n"

        "typedef uint8_t bool;\n"
        "typedef uint8_t byte;\n"
        "typedef uint16_t word;\n"
        "typedef uint32_t dword;\n\n"

        "#endif\n\n"

        "#pragma pack(push, 1)\n\n"
        "union Register32 {\n"
        "    int32_t all;\n"
        "    struct {\n"
        "        union {\n"
        "            struct {\n"
        "                int8_t lo8;\n"
        "                int8_t hi8;\n"
        "            };\n"
        "            int16_t lo16;\n"
        "        };\n"
        "        int16_t hi16;\n"
        "    };\n"
        "};\n"
        "typedef union Register32 Register32;\n"
        "\nstruct Flags\n"
        "{\n"
        "    bool carry;\n"
        "    bool zero;\n"
        "    bool sign;\n"
        "    bool overflow;\n"
        "    bool direction;\n"
        "};\n"
        "typedef struct Flags Flags;\n"
        "\n#pragma pack(pop)\n\n"

        "#ifdef __cplusplus\n"
        "extern \"C\" {\n"
        "#endif\n"
        "extern union Register32 g_eax, g_ebx, g_ecx, g_edx, g_esi, g_edi, g_ebp, g_tmp;\n"
        "#ifndef __cplusplus\n"
        "extern dword A0, A1, A2, A3, A4, A5, A6, D0, D1, D2, D3, D4, D5, D6, D7; \n"
        "#endif\n"
        "extern Flags g_flags;\n"
        "extern int32_t g_stack[" kVmStackSize "];\n"
        "#ifndef sizeofarray\n"
        "# define sizeofarray(a) (sizeof(a) / sizeof((a)[0]))\n"
        "#endif\n"
        "extern int32_t g_stackTop;\n"
        "#ifdef __cplusplus\n"
        "}\n"
        "#endif\n\n"
        "#ifndef __cplusplus\n"
        "# define push(a) (g_stack[--g_stackTop] = (a))\n"
        "# define pop(a) ((a) = g_stack[g_stackTop++])\n\n"
        "# define eax (g_eax.all)\n"
        "# define ebx (g_ebx.all)\n"
        "# define ecx (g_ecx.all)\n"
        "# define edx (g_edx.all)\n"
        "# define esi (g_esi.all)\n"
        "# define edi (g_edi.all)\n"
        "# define ebp (g_ebp.all)\n"
        "# define ax (g_eax.lo16)\n"
        "# define bx (g_ebx.lo16)\n"
        "# define cx (g_ecx.lo16)\n"
        "# define dx (g_edx.lo16)\n"
        "# define si (g_esi.lo16)\n"
        "# define di (g_edi.lo16)\n"
        "# define bp (g_ebp.lo16)\n"
        "# define ah (g_eax.hi8)\n"
        "# define al (g_eax.lo8)\n"
        "# define bh (g_ebx.hi8)\n"
        "# define bl (g_ebx.lo8)\n"
        "# define ch (g_ecx.hi8)\n"
        "# define cl (g_ecx.lo8)\n"
        "# define dh (g_edx.hi8)\n"
        "# define dl (g_edx.lo8)\n"
        "#endif\n\n"

        "#undef __out  // some VC++ weirdness\n"
    ;
    constexpr char kVmCFileContents[] =
        kAutoGeneratedWarning
        "#include \"" kVmHeaderFilename "\"\n\n"
        "Flags g_flags;\n"
        "Register32 g_eax, g_ebx, g_ecx, g_edx, g_esi, g_edi, g_ebp, g_tmp;\n"
        "// place 68k registers near x86 ones to use the cache better\n"
        "dword A0, A1, A2, A3, A4, A5, A6,D0, D1, D2, D3, D4, D5, D6, D7;\n"
        "int32_t g_stack[" kVmStackSize "];\n"
        "int32_t g_stackTop = sizeofarray(g_stack);\n"
    ;

    return outputFile(kVmHeaderFilename, kVmHeaderContents, sizeof(kVmHeaderContents) - 1) &&
        outputFile(kVmCFilename, kVmCFileContents, sizeof(kVmCFileContents) - 1);
}

void COutput::outputStructs()
{
    if (!m_structs.empty())
        out("#pragma pack(push, 1)", Util::kNewLine);

    for (auto& struc : m_structs) {
        if (struc.resolved())
            continue;

        for (const auto& field : struc) {
            if (!field.elementSize()) {
                auto structName = field.type();
                auto nestedStruct = m_structs.findStruct(structName);

                assert(nestedStruct);
                if (nestedStruct && !nestedStruct->resolved())
                    outputStruct(*nestedStruct);
            }
        }

        outputStruct(struc);
    }

    if (!m_structs.empty())
        out("#pragma pack(pop)", Util::kNewLine);
}

void COutput::outputStruct(Struct& struc)
{
    outputComment(struc.leadingComments(), false);
    out(struc.isUnion() ? "union " : "struct ", struc.name(), Util::kNewLine, '{', Util::kNewLine);

    char anonBuf[32];
    int anonCounter = 0;

    for (const auto& field : struc) {
        if (!field.type().empty()) {
            out(kIndent, field.type(), ' ');
        } else {
            auto sizeSpecifier = getTypeInfo(field.elementSize()).unsignedType;
            out(kIndent, sizeSpecifier, ' ');
        }

        if (!field.name().empty()) {
            out(field.name());
        } else {
            sprintf(anonBuf, "%02d", anonCounter++);
            out(anonBuf);
        }

        if (!field.dup().empty())
            out('[', field.dup(), ']');

        out(';', Util::kNewLine);
    }

    out("};", Util::kNewLine);
    out("typedef ", struc.isUnion() ? "union " : "struct ", struc.name(), ' ', struc.name(), ';', Util::kNewLine);
    struc.resolve();
}

void COutput::outputTableStructs()
{
    resetAutoDataIndex();

    if (!m_tableVarRanges.empty())
        out(Util::kNewLine);

    for (size_t i = 0; i < m_tableVarRanges.size(); i++) {
        const auto& range = m_tableVarRanges[i];

        auto tableIndex = getGlobalTableIndex(i);
        out(kTableTypeStem, tableIndex, " " kTableVarStem, tableIndex, " = {", Util::kNewLine);

        for (auto item = range.first; item <= range.second; item = item->next()) {
            auto dataItem = item->getItem<DataItem>();

            out(kIndent, "{ ");

            if (dataItem->numElements() > 0) {
                auto elem = dataItem->begin();
                if (elem->type() == DataItem::kLabel && !m_references.hasReference(elem->text()) && lastOutputChar() != '&')
                    out('&');
            }

            item = outputDataItem(item, kValueOnly);
            out(" },", Util::kNewLine);
        }

        out("};", Util::kNewLine);
    }
}

void COutput::outputStructVarCppDefines(const std::vector<std::tuple<String, String, size_t, size_t>>& cppDefines, int tableIndex)
{
    if (!cppDefines.empty()) {
        out("#else", Util::kNewLine);
        for (const auto& defData : cppDefines) {
            String var, type;
            size_t varOfs, varLen;
            std::tie(var, type, varOfs, varLen) = defData;

            // int var       -> (*((int *)&myWord))
            // void (*var)() -> (*((void (**)())&whateva))

            char buf[512] = { "*((" };
            constexpr size_t kStartOfs = 3;
            assert(type.length() - varLen + kStartOfs + 2 <= sizeof(buf));

            auto len = kStartOfs;
            type.substr(0, varOfs).copy(buf + len);
            type.substr(varOfs + varLen).copy(buf + len + varOfs);
            len += type.length() - varLen;

            int startOfs = 0;

            if (buf[len - 1] == ']') {
                do {
                    len--;
                } while (buf[len - 1] != '[');

                assert(len < sizeof(buf));
                buf[len - 1] = '*';

                startOfs = 1;
            } else {
                bool isFunctionCast = len == kStartOfs + 10 && !memcmp(buf + kStartOfs, "void (*)()", 10);
                if (isFunctionCast) {
                    buf[len - 3] = '*';
                    buf[len - 2] = ')';
                    buf[len - 1] = '(';
                    buf[len++] = ')';
                } else {
                    buf[len++] = '*';
                }
            }

            buf[len++] = ')';
            String cast(buf + startOfs, len - startOfs);

                out("# define ", var, " (", cast, '&', kTableVarStem, tableIndex, '.', var, "))", Util::kNewLine);
            }
        }
}

bool COutput::outputExterns()
{
    if (m_references.externs().empty())
        return true;

    bool result = true;

    for (auto ext : m_references.externs()) {
        const auto& name = std::get<0>(ext);
        const auto& refType = std::get<1>(ext);
        const auto& customType = std::get<2>(ext);

        assert(name.length() && name.data());
        if (amigaRegisterToIndex(name) >= 0)
            continue;

        out("extern ");

        switch (refType) {
        case References::kByte: out("byte"); break;
        case References::kWord: out("int16_t"); break;
        case References::kDword: out("int32_t"); break;
        case References::kQWord: out("int64_t"); break;
        case References::kTbyte: out("int8_t"); break;
        case References::kNear:
        case References::kProc: out("void"); break;
        case References::kUser: out(customType); break;
        default:
            if (!m_error.empty())
                m_error += '\n';
            m_error += std::string("undefined reference found: ") + name.string();
            result = false;
        }

        out(' ', name);
        if (refType == References::kNear || refType == References::kProc)
            out("()");
        else if (refType == References::kTbyte)
            out("[10]");

        out(';', Util::kNewLine);
    }

    out(Util::kNewLine);

    return result;
}

void COutput::outputDefines()
{
    for (auto it : m_defines) {
        auto def = it.cargo;

        outputComment(def->leadingComments(), false);
        out("#define ", def->name(), " ");

        if (def->isInverted())
            out('~');

        if (def->value().endsWith('h'))
            out("0x", def->value().withoutLast());
        else
            out(def->value());

        outputComment(def->comment());
    }
}

void COutput::outputCodeAndData()
{
    runFirstPass();
    resetAutoDataIndex();

    for (auto it = m_outputItems.begin(); it != m_outputItems.end(); ++it) {
        auto nextItem = it->next() != m_outputItems.end() ? it->next() : nullptr;

        switch (it->type()) {
        case OutputItem::kInstruction:
            {
                if (!m_insideProc)
                    continue;

                auto instruction = it->getItem<Instruction>();
                auto skipped = checkForSwitchTable(it, instruction);
                if (skipped != it) {
                    it = skipped;
                    continue;
                }

                assert(it != m_outputItems.end());

                if (!nextItem || isFinalRetn(*it))
                    continue;

                outputInstruction(instruction);
            }
            break;
        case OutputItem::kDataItem:
            if (!isTableVar(&it)) {
                it = outputDataItem(it, kDefine);
            } else {
                auto dataItem = it->getItem<DataItem>();
                if (dataItem->name().empty())
                    m_dataIndex++;
                it = findLastBelongingItem(it);
            }
            break;
        case OutputItem::kProc:
            outputProc(it->getItem<Proc>());
            break;
        case OutputItem::kEndProc:
            outputEndProc(it->getItem<EndProc>(), it->comment(), it->next());
            break;
        case OutputItem::kLabel:
            outputLabel(it->getItem<Label>());
            break;
        case OutputItem::kStackVariable:
            outputStackVariable(it->getItem<StackVariable>());
            break;
            // ignore everything else and hope it doesn't blow up
        }
    }

    if (m_insideProc)
        out('}', Util::kNewLine);
}

// Since assembler might reference labels without declaring them first, we'll simply forward declare all the data.
// Also divide labels into global (outside a proc) and local (inside a proc).
void COutput::runFirstPass()
{
    bool inProc = false;
    resetAutoDataIndex();

    out(Util::kNewLine, "// first pass forward declarations", Util::kNewLine);

    for (auto it = m_outputItems.begin(); it != m_outputItems.end(); ++it) {
        switch (it->type()) {
        case OutputItem::kDataItem:
            it = outputDataItem(it, kDeclareExtern, true);
            break;
        case OutputItem::kProc:
            {
                auto proc = it->getItem<Proc>();
                out("void ", proc->name(), "();", Util::kNewLine);
                inProc = true;
            }
            break;
        case OutputItem::kEndProc:
            inProc = false;
            break;
        case OutputItem::kLabel:
            if (inProc) {
                auto label = it->getItem<Label>();
                if (!label->isLocal())
                    m_inProcLabels.add(label->name());
            }
            break;
        }
    }

    out(Util::kNewLine);

    resetAutoDataIndex();

    m_inProcLabels.seal();
}

void COutput::outputInstruction(const Instruction *instruction)
{
    assert(m_insideProc);
    out(kIndent);

    auto initialOutputPtr = getOutputPtr();

    switch (instruction->type()) {
    case Token::T_NOP:
        // ignore
        break;
    case Token::T_MOV:
    case Token::T_MOVZX:
    case Token::T_MOVSX:
        outputMov(instruction);
        break;
    case Token::T_MOVSB:
    case Token::T_MOVSW:
    case Token::T_MOVSD:
        outputMovs(instruction);
        break;
    case Token::T_LODSB:
    case Token::T_LODSW:
    case Token::T_LODS:
        outputLods(instruction);
        break;
    case Token::T_STOSB:
    case Token::T_STOSW:
    case Token::T_STOSD:
        outputStos(instruction);
        break;
    case Token::T_CALL:
        outputCall(instruction);
        break;
    case Token::T_PUSH:
    case Token::T_POP:
        outputPushPop(instruction);
        break;
    case Token::T_CBW:
        outputCbw(instruction);
        break;
    case Token::T_CWDE:
        outputCwde(instruction);
        break;
    case Token::T_CDQ:
        outputCdq(instruction);
        break;
    case Token::T_RETN:
        out("return");
        break;
    case Token::T_JMP:
        outputJmp(instruction);
        break;
    case Token::T_JG:
        outputJg(instruction);
        break;
    case Token::T_JGE:
        outputJge(instruction);
        break;
    case Token::T_JL:
        outputJl(instruction);
        break;
    case Token::T_JZ:
        outputJz(instruction);
        break;
    case Token::T_JNZ:
        outputJnz(instruction);
        break;
    case Token::T_JS:
        outputJs(instruction);
        break;
    case Token::T_JNS:
        outputJns(instruction);
        break;
    case Token::T_JA:
        outputJa(instruction);
        break;
    case Token::T_JB:
        outputJb(instruction);
        break;
    case Token::T_JNB:
        outputJnb(instruction);
        break;
    case Token::T_JBE:
        outputJbe(instruction);
        break;
    case Token::T_JO:
        outputJo(instruction);
        break;
    case Token::T_JNO:
        outputJno(instruction);
        break;
    case Token::T_JLE:
        outputJle(instruction);
        break;
    case Token::T_OR:
    case Token::T_XOR:
        outputOrXor(instruction);
        break;
    case Token::T_CMP:
        outputCmpSubAdd(instruction, false, false);
        break;
    case Token::T_INC:
        outputIncDec(instruction, true);
        break;
    case Token::T_DEC:
        outputIncDec(instruction, false);
        break;
    case Token::T_AND:
        outputAndTest(instruction, true);
        break;
    case Token::T_XCHG:
        outputXchg(instruction);
        break;
    case Token::T_SUB:
        outputCmpSubAdd(instruction, true, false);
        break;
    case Token::T_ADD:
        outputCmpSubAdd(instruction, true, true);
        break;
    case Token::T_MUL:
        outputMul(instruction);
        break;
    case Token::T_IMUL:
        outputImul(instruction);
        break;
    case Token::T_DIV:
    case Token::T_IDIV:
        outputDiv(instruction);
        break;
    case Token::T_TEST:
        outputAndTest(instruction, false);
        break;
    case Token::T_SHL:
    case Token::T_SHR:
    case Token::T_SAR:
        outputShift(instruction);
        break;
    case Token::T_RCR:
    case Token::T_RCL:
    case Token::T_ROL:
    case Token::T_ROR:
        outputRotate(instruction);
        break;
    case Token::T_INT:
    case Token::T_IN:
    case Token::T_OUT:
    case Token::T_CLI:
    case Token::T_STI:
        outputIntInOut(instruction);
        break;
    case Token::T_NEG:
        outputNeg(instruction);
        break;
    case Token::T_NOT:
        outputNot(instruction);
        break;
    case Token::T_LOOP:
        outputLoop(instruction);
        break;
    case Token::T_PUSHF:
        outputPushf(instruction);
        break;
    case Token::T_POPF:
        outputPopf(instruction);
        break;
    case Token::T_PUSHA:
        outputPusha(instruction);
        break;
    case Token::T_POPA:
        outputPopa(instruction);
        break;
    case Token::T_STC:
        outputStc(instruction);
        break;
    case Token::T_CLC:
        outputClc(instruction);
        break;
    case Token::T_CLD:
        outputCld(instruction);
        break;
    case Token::T_SETZ:
        outputSetz(instruction);
        break;
    default:
        assert(false);
        out("// ", instruction->instructionText(), " unimplemented!");
    }

    bool hadOutput = getOutputPtr() != initialOutputPtr;
    if (hadOutput) {
        if (lastOutputChar() != '}')
            out(';');

        outputOriginalInstructionComment(instruction, initialOutputPtr - sizeof(kIndent));

        if (instruction->isBranch() && instruction->type() != Token::T_CALL)
            out(Util::kNewLine);
    } else {
        removeOutputChar(kTabSize);
    }
}

const OutputItem *COutput::outputDataItem(const OutputItem *item, DataItemOutputFormat format, bool checkTableVar /* = false */)
{
    assert(item->type() == OutputItem::kDataItem);

    auto dataItem = item->getItem<DataItem>();
    auto numElements = dataItem->numElements();
    bool isOffset = numElements == 1 && dataItem->begin()->isOffset();

    char nameBuff[256];
    auto name = getDataItemName(dataItem, nameBuff);
    assert(name.length() < sizeof(nameBuff));

    if (amigaRegisterToIndex(name) >= 0)
        return item;

    if (checkTableVar && isTableVar(item))
        return item;

    auto skipped = checkForSwitchTable(item, dataItem);
    if (skipped != item)
        return skipped;

    auto lastItem = findLastBelongingItem(item);
    auto arraySize = getDataItemArraySize(item, lastItem);

    if (format == kDeclareExtern) {
        out("extern ");
    } else if (format == kValueOnly) {
        outputDataItemValue(item, lastItem, isOffset);
        return lastItem;
    }

    outputDataItemType(dataItem, format, name, arraySize, isOffset);

    if (format == kDeclare || format == kDeclareExtern) {
        out(';', Util::kNewLine);
        return lastItem;
    }

    if (numElements > 0)
        out(" = ");

    if (isOffset && lastOutputChar() != '&')
        out('&');

    if (arraySize > 0)
        out('{');

    outputDataItemValue(item, lastItem, isOffset);

    if (arraySize > 0)
        out('}');

    out(';', Util::kNewLine);

    if (lastItem != m_outputItems.end() && lastItem->next()->type() == OutputItem::kProc)
        out(Util::kNewLine);

    return lastItem;
}

String COutput::getDataItemName(const DataItem *dataItem, char *nameBuff)
{
    auto name = dataItem->name();

    if (name.empty()) {
        assert(m_dataIndex < (m_index + 1) * kMaxAutoGeneratedItems);
        auto len = getNextAutoVar(nameBuff);
        name.assign(nameBuff, len);
    }

    return name;
}

// Keep all belonging data lines together, for example if a long array is being split in multiple lines -- only
// first line will have a label, rest of them will be anonymous
const OutputItem *COutput::findLastBelongingItem(const OutputItem *item)
{
    assert(item && item < m_outputItems.end() && item->type() == OutputItem::kDataItem);

    auto dataItem = item->getItem<DataItem>();
    if (dataItem->numElements() <= 1)
        return item;

    bool isString = dataItem->numElements() == 2 && dataItem->begin()->type() == DataItem::kString &&
        dataItem->begin()->next()->isNumber();
    if (isString)
        return item;

    auto size = dataItem->size();

    while (canConsumeItem(size, item->next())) {
        item = item->next();
        assert(item->type() == OutputItem::kDataItem && item->getItem<DataItem>()->name().empty());
        m_dataIndex++;
    }

    return item;
}

size_t COutput::getDataItemArraySize(const OutputItem *first, const OutputItem *last)
{
    assert(first && first < m_outputItems.end() && first->type() == OutputItem::kDataItem);
    assert(first <= last && last);

    size_t numElements = 0;

    for (auto item = first; item <= last; item = item->next()) {
        auto dataItem = item->getItem<DataItem>();
        auto element = dataItem->begin();

        for (size_t i = 0; i < dataItem->numElements(); i++, element = element->next()) {
            assert(i == 0 || !(element->type() & DataItem::kIsOffsetFlag));

            if (element->dup()) {
                numElements += element->dup();
            } else {
                if (element->type() == DataItem::kString)
                    numElements += element->text().length() - 2;
                else
                    numElements += element->dup() ? element->dup() : 1;
            }
        }
    }

    return numElements > 1 ? numElements : 0;
}

void COutput::outputDataItemType(const DataItem *dataItem, DataItemOutputFormat format, const String& name, size_t arraySize, bool isOffset)
{
    if (isOffset) {
        out("void *");
    } else if (!dataItem->structName().empty()) {
        out(dataItem->structName(), ' ');
    } else {
        if (dataItem->size() == 1 && isString(dataItem)) {
            out("const char ");
        } else {
            auto typeInfo = getTypeInfo(dataItem->size());
            out(typeInfo.unsignedType, ' ');
        }
    }

    out(name);

    if (arraySize > 0)
        out('[', arraySize, ']');
}

void COutput::outputDataItemValue(const OutputItem *first, const OutputItem *last, bool isOffset)
{
    assert(first && first < m_outputItems.end() && first->type() == OutputItem::kDataItem);
    assert(last && first <= last);

    constexpr int kLineLength = 110;
    auto lineStart = getOutputPtr() + 15;

    auto breakLineIfNeeded = [&]() {
        if (getOutputPtr() - lineStart > kLineLength) {
            if (lastOutputChar() == ' ')
                removeOutputChar();
            out(Util::kNewLine, kIndent);
            lineStart = getOutputPtr();
        }
    };

    if (isZeroInitArray(first)) {
        out('0');
        return;
    }

    for (auto item = first; item <= last; item = item->next()) {
        auto dataItem = item->getItem<DataItem>();
        auto numElements = dataItem->numElements();
        auto element = dataItem->begin();

        for (size_t i = 0; i < numElements; i++, element = element->next()) {
            bool last = i == numElements - 1;
            bool zeroTerminate = false;

            if (numElements == 2 && element->type() == DataItem::kString && !last) {
                auto next = element->next();
                if (next->isNumber() && next->value() == 0)
                    zeroTerminate = true;
            }

            if (element->dup()) {
                if (lastOutputChar() == ',')
                    out(' ');

                for (size_t i = 0; i < element->dup() - 1; i++) {
                    outputItem(element, false);
                    out(", ");
                    breakLineIfNeeded();
                }
            }

            outputItem(element, zeroTerminate);

            if (isOffset && element->offset())
                out('+', element->offset());

            if (!last && zeroTerminate) {
                assert(!element->dup());
                element = element->next();
                i++;
            }

            out(',');

            if (!last) {
                if (!zeroTerminate)
                    out(' ');

                breakLineIfNeeded();
            }
        }
    }

    if (lastOutputChar() == ',')
        removeOutputChar();
}

bool COutput::isZeroInitArray(const OutputItem *item)
{
    assert(item && item < m_outputItems.end() && item->type() == OutputItem::kDataItem);

    auto dataItem = item->getItem<DataItem>();
    if (dataItem->numElements() == 1) {
        auto element = dataItem->begin();
        if (element->dup() && element->value() == 0)
            return true;
    }

    return false;
}

bool COutput::canConsumeItem(size_t size, const OutputItem *item) const
{
    assert(item);

    if (item < m_outputItems.end() && item->type() == OutputItem::kDataItem) {
        auto dataItem = item->getItem<DataItem>();
        return dataItem->name().empty() && dataItem->size() == size;
    }

    return false;
}

bool COutput::isString(const DataItem *item)
{
    assert(item->numElements() > 0);

    auto element = item->begin();

    if (item->numElements() < 3 && item->begin()->type() == DataItem::kString) {
        if (item->numElements() == 1)
            return true;

        auto endElement = item->begin()->next();
        if (endElement->isNumber() && endElement->value() == 0)
            return true;
    }

    return false;
}

void COutput::outputItem(const DataItem::Element *element, bool zeroTerminate)
{
    assert(element);
    const auto& text = element->text();

    if (lastOutputChar() == ',')
        out(' ');

    if (element->type() == DataItem::kHex) {
        outputToken(text, Token::T_HEX);
    } else if (element->type() == DataItem::kBin) {
        outputToken(text, Token::T_BIN);
    } else if (element->type() == DataItem::kString) {
        assert(text.first() == '\'' && text.last() == '\'');

        if (zeroTerminate) {
            outputToken(text, Token::T_STRING, false);
        } else {
            for (size_t i = 1; i < text.length() - 1; i++) {
                out('\'');
                if (text[i] == '\'')
                    out("\\'");
                else if (text[i] == '\\')
                    out("\\\\");
                else
                    out(text[i]);
                out('\'');

                if (i < text.length() - 2)
                    out(',');
            }
        }
    } else if (text == "<0>") {
        out("{0}");
    } else {
        if (element->type() == DataItem::kLabel) {
            auto dotIndex = text.indexOf('.');
            if (dotIndex >= 0 && text.contains("Sprite")) {
                // FFS IDA you're killing me
                auto field = text.substr(dotIndex + 1);

                char buf[256] = "Sprite.";
                field.copy(buf + strlen(buf));

                auto offsetHolder = m_structMap.get(buf, strlen(buf));
                assert(offsetHolder);

                assert(lastOutputChar() == '&');
                removeOutputChar();

                out("(char *)&", text.substr(0, dotIndex), '+', static_cast<int>(offsetHolder->offset()));
                return;
            }
        }

        if (element->isOffset() && lastOutputChar() != '&')
            out('&');

        out(text);
    }
}

void COutput::outputProc(const Proc *proc)
{
    if (m_insideProc)
        out('}', Util::kDoubleNewLine);

    m_insideProc = true;

    out("void ", proc->name(), "()", Util::kNewLine, '{', Util::kNewLine);
}

void COutput::outputEndProc(const EndProc *endProc, const String& comment, const OutputItem *next)
{
    assert(m_insideProc);

    m_insideProc = false;

    if (outputLength() >= Util::kDoubleNewLine.size()) {
        auto testStart = getOutputPtr() - Util::kDoubleNewLine.size() - 1;
        if (!memcmp(testStart, Util::kDoubleNewLine.data(), Util::kDoubleNewLine.size()))
            removeOutputChar(Util::kNewLine.size());
    }

    out('}', Util::kDoubleNewLine);
}

void COutput::outputLabel(const Label *label)
{
    if (label->name() == "return")
        return;

    if (m_insideProc) {
        if (!isLastLineEmpty())
            out(Util::kNewLine);

        outputLabel(label->name());
        out(":;");
    } else {
        out("// ", label->name());
    }

    out(Util::kNewLine);
}

void COutput::outputStackVariable(const StackVariable *var)
{
    out(kIndent, var->sizeString(), ' ', var->name(), " = 0;", Util::kNewLine);
}

void COutput::outputMov(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    assert(!src.base.empty() && !dst.base.empty());
    assert(!src.size || !dst.size || (instruction->type() == Token::T_MOV ? dst.size == src.size :
        (dst.size != src.size || src.structField && dst.straightReg || src.straightReg && dst.structField)));
    assert(!(src.pointer && src.address) && !(dst.pointer && dst.address));

    outputInstructionArgument(dst, src.address, src.size);

    // I'm sowwy
    if (dst.base == "newJobOffers.teamName")
        out("[0]");

    out(" = ");

    if (instruction->type() == Token::T_MOVSX) {
        auto typeInfo = getTypeInfo(src.size);
        out('(', typeInfo.signedType, ")(");
    }

    outputInstructionArgument(src, dst.address, dst.size);

    if (instruction->type() == Token::T_MOVSX)
        out(')');
}

void COutput::outputMovs(const Instruction *instruction)
{
    out('{', Util::kNewLine);
    out(kIndent, kIndent, "int inc = g_flags.direction ? -");

    auto type = "";
    auto size = "";

    switch (instruction->type()) {
    case Token::T_MOVSB:
        type = "byte";
        size = "1";
        break;
    case Token::T_MOVSW:
        type = "word";
        size = "2";
        break;
    case Token::T_MOVSD:
        type = "dword";
        size = "4";
        break;
    default:
        assert(false);
    }

    out(size, " : +", size, ';', Util::kNewLine);

    assert(instruction->prefix() == "rep");

    if (instruction->prefix() == "rep")
        out(kIndent, kIndent, "for (; ecx; ecx--)", Util::kNewLine, kIndent);

    out(kIndent, kIndent, "*(", type, " *)edi = *(", type, " *)esi, edi += inc, esi += inc;", Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputStos(const Instruction *instruction)
{
    out('{', Util::kNewLine);
    out(kIndent, kIndent, "int inc = g_flags.direction ? -");

    auto type = "";
    auto reg = "";
    auto size = "";

    switch (instruction->type()) {
    case Token::T_STOSB:
        type = "byte";
        reg = "al";
        size = "1";
        break;
    case Token::T_STOSW:
        type = "word";
        reg = "ax";
        size = "2";
        break;
    case Token::T_STOSD:
        type = "dword";
        reg = "eax";
        size = "4";
        break;
    default:
        assert(false);
    }

    out(size, " : +", size, ';', Util::kNewLine);

    assert(instruction->prefix().empty() || instruction->prefix() == "rep");

    if (instruction->prefix() == "rep")
        out(kIndent, kIndent, "for (; ecx; ecx--)", Util::kNewLine, kIndent);

    out(kIndent, kIndent, "*(", type, " *)edi = ", reg, ", edi += inc;", Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputLods(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0 && instruction->prefix().empty());

    out('{', Util::kNewLine);
    out(kIndent, kIndent, "int inc = g_flags.direction ? -");

    auto type = "";
    auto reg = "";
    auto size = "";

    switch (instruction->type()) {
    case Token::T_LODSB:
        type = "byte";
        reg = "al";
        size = "1";
        break;
    case Token::T_LODSW:
        type = "word";
        reg = "ax";
        size = "2";
        break;
    case Token::T_LODS:
        type = "dword";
        reg = "eax";
        size = "4";
        break;
    default:
        assert(false);
    }

    out(size, " : +", size, ';', Util::kNewLine);

    out(kIndent, kIndent, reg, " = *(", type, " *)esi, esi += inc;", Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputCall(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    const auto& operand = instruction->operands()[0];
    const auto target = operand.begin();
    const auto& text = target->text();

    if (!text.startsWith('$')) {
        assert(target->next() == operand.end());
        outputFunctionInvoke(text);
    }
}

void COutput::outputPushPop(const Instruction *instruction)
{
    assert(instruction->type() == Token::T_PUSH || instruction->type() == Token::T_POP);
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);
    auto op = params[0];

    // get rid of push/pop small crap
    op.size = 4;
    op.pointer = false;
    op.dereference = false;

    out(instruction->type() == Token::T_PUSH ? "push(" : "pop(");
    outputInstructionArgument(op);
    out(')');
}

void COutput::outputCbw(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("ah = (int8_t)al < 0 ? -1 : 0");
}

void COutput::outputCwde(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("g_eax.hi16 = (int16_t)ax < 0 ? -1 : 0");
}

void COutput::outputCdq(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("edx = (int32_t)eax < 0 ? -1 : 0");
}

void COutput::outputOrXor(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);
    out(kIndent, kIndent, typeInfo.unsignedType, " res = ");

    outputInstructionArgument(dst, src.address);

    switch (instruction->type()) {
    case Token::T_OR: out(" |= "); break;
    case Token::T_XOR: out(" ^= "); break;
    default: assert(false);
    }

    outputInstructionArgument(src, dst.address, dst.size);
    out(';', Util::kNewLine);

    out(kIndent, kIndent, "g_flags.overflow = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.carry = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.sign = (res & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = res == 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputCmpSubAdd(const Instruction *instruction, bool commitResult, bool add)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)&(");
    outputInstructionArgument(dst, src.address);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " src = (", typeInfo.signedType, ')');
    outputInstructionArgument(src, dst.address, dst.size);
    out(';', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " res = *dst ", add ? '+' : '-', " src;", Util::kDoubleNewLine);

    out(kIndent, kIndent, "g_flags.overflow = *dst < 0 ? src > *dst - ", typeInfo.signedMin,
        " : src < *dst - ", typeInfo.signedMax, ';', Util::kNewLine);
    out(kIndent, kIndent, "g_flags.carry = (", typeInfo.unsignedType, ")(*dst ", add ? '+' : '-', " src) ",
        add ? '<' : '>', " (", typeInfo.unsignedType, ")*dst;", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.sign = (res & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = res == 0;", Util::kNewLine);

    if (commitResult)
        out(kIndent, kIndent, "*dst = res;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputIncDec(const Instruction *instruction, bool increment)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)&(");
    outputInstructionArgument(op);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.overflow = (*dst)", increment ? "++" : "--", " == ",
        increment ? typeInfo.signedMax : typeInfo.signedMin, ';', Util::kNewLine);
    out(kIndent, kIndent, "g_flags.sign = (*dst & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = *dst == 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputAndTest(const Instruction *instruction, bool commitResult)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " res = ");
    outputInstructionArgument(dst, src.address);
    out(" & ");
    outputInstructionArgument(src, dst.address, dst.size);
    out(';', Util::kNewLine);

    if (commitResult) {
        out(kIndent, kIndent);
        outputInstructionArgument(dst, src.address);
        out(" = res;", Util::kNewLine);
    }

    out(kIndent, kIndent, "g_flags.overflow = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.carry = false;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.sign = (res & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = res == 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputXchg(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& src = params[1];

    auto typeInfo = getTypeInfo(dst.size | src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " *dst = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(dst, src.address);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " *src = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(src, dst.address, dst.size);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "*(", typeInfo.unsignedType, " *)&g_tmp = *dst;", Util::kNewLine);
    out(kIndent, kIndent, "*dst = *src;", Util::kNewLine);
    out(kIndent, kIndent, "*src = *(", typeInfo.unsignedType, " *)&g_tmp;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputMul(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);
    const auto& src = params[0];

    assert(src.size);
    auto typeInfo = getTypeInfo(src.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " src = ");
    outputInstructionArgument(src);
    out(';', Util::kNewLine);

    switch (src.size) {
    case 1:
        out(kIndent, kIndent, "ax = al * src;", Util::kNewLine);
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = ah != 0;", Util::kNewLine);
        break;
    case 2:
        out(kIndent, kIndent, "g_tmp.all = ax * src;", Util::kNewLine);
        out(kIndent, kIndent, "ax = g_tmp.lo16;", Util::kNewLine);
        out(kIndent, kIndent, "dx = g_tmp.hi16;", Util::kNewLine);
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = dx != 0;", Util::kNewLine);
        break;
    case 4:
        out(kIndent, kIndent, "uint64_t res = eax * src;", Util::kNewLine);
        out(kIndent, kIndent, "eax = res & 0xffffffff;", Util::kNewLine);
        out(kIndent, kIndent, "edx = res >> 32;", Util::kNewLine);
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = edx != 0;", Util::kNewLine);
        break;
    default:
        assert(false);
        break;
    }

    out(kIndent, '}');
}

void COutput::outputImul(const Instruction *instruction)
{
    assert(instruction->numOperands() > 0);

    auto params = getOperandsInfo(instruction);
    const auto& dst = params[0];

    assert(dst.size);
    auto typeInfo = getTypeInfo(dst.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, ' ', instruction->numOperands() == 1 ? "src" : "dst", " = ");
    outputInstructionArgument(dst);
    out(';', Util::kNewLine);

    if (instruction->numOperands() == 1) {
        const auto& src = dst;

        switch (src.size) {
        case 1:
            out(kIndent, kIndent, "ax = (int8_t)al * src;", Util::kNewLine);
            out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = (int8_t)ax != (int8_t)al;", Util::kNewLine);
            break;
        case 2:
            out(kIndent, kIndent, "g_tmp.all = (int16_t)ax * src;", Util::kNewLine);
            out(kIndent, kIndent, "ax = (int16_t)g_tmp.lo16;", Util::kNewLine);
            out(kIndent, kIndent, "dx = (int16_t)g_tmp.hi16;", Util::kNewLine);
            out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = (int32_t)g_tmp.all != (int16_t)ax;", Util::kNewLine);
            break;
        case 4:
            out(kIndent, kIndent, "int64_t res = eax * src;", Util::kNewLine);
            out(kIndent, kIndent, "eax = res & 0xffffffff;", Util::kNewLine);
            out(kIndent, kIndent, "edx = res >> 32;", Util::kNewLine);
            out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = res != (int32_t)eax;", Util::kNewLine);
            break;
        default:
            assert(false);
            break;
        }
    } else {
        const auto& src = params[1];

        assert(dst.size == src.size && (dst.size == 2 || dst.size == 4));

        out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)&(");
        outputInstructionArgument(dst, src.address);
        out(");", Util::kNewLine);

        out(kIndent, kIndent, typeInfo.signedType, " src = ");
        outputInstructionArgument(src);
        out(';', Util::kNewLine);

        if (instruction->numOperands() == 3) {
            out(kIndent, kIndent, typeInfo.nextLargerSignedType, " tmp = *dst * src;");
        } else {
            assert(instruction->numOperands() == 3);

            const auto& src2 = params[2];

            out(kIndent, kIndent, typeInfo.signedType, " src2 = ");
            outputInstructionArgument(src2);
            out(';', Util::kNewLine);

            out(kIndent, kIndent, typeInfo.nextLargerSignedType, " tmp = src * src2;");
        }

        out(kIndent, kIndent, "*dst = tmp;");
        out(kIndent, kIndent, "g_flags.carry = g_flags.overflow = *dst != tmp;");
    }

    out(kIndent, '}');
}

void COutput::outputDiv(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);
    const auto& src = params[0];

    assert(src.size);
    auto typeInfo = getTypeInfo(src.size);

    out('{', Util::kNewLine);

    bool signedDiv = instruction->type() == Token::T_IDIV;
    auto type = signedDiv ? typeInfo.signedType : typeInfo.unsignedType;

    out(kIndent, kIndent, type, " src = ");
    if (signedDiv)
        out('(', type, ')');
    outputInstructionArgument(src);
    out(';', Util::kNewLine);

    // we will ignore overflow and division by zero
    switch (src.size) {
    case 1:
        if (signedDiv) {
            out(kIndent, kIndent, "int8_t quot = (int16_t)ax / src;", Util::kNewLine);
            out(kIndent, kIndent, "int8_t rem = (int16_t)ax % src;", Util::kNewLine);
        } else {
            out(kIndent, kIndent, "byte quot = ax / src;", Util::kNewLine);
            out(kIndent, kIndent, "byte rem = ax % src;", Util::kNewLine);
        }

        out(kIndent, kIndent, "al = quot;", Util::kNewLine);
        out(kIndent, kIndent, "ah = rem;", Util::kNewLine);
        break;
    case 2:
        if (signedDiv) {
            out(kIndent, kIndent, "int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;", Util::kNewLine);
            out(kIndent, kIndent, "int16_t quot = (int16_t)(dividend / src);", Util::kNewLine);
            out(kIndent, kIndent, "int16_t rem = (int16_t)(dividend % src);", Util::kNewLine);
        } else {
            out(kIndent, kIndent, "dword dividend = (dx << 16) | ax;", Util::kNewLine);
            out(kIndent, kIndent, "word quot = (word)(dividend / src);", Util::kNewLine);
            out(kIndent, kIndent, "word rem = (word)(dividend % src);", Util::kNewLine);
        }

        out(kIndent, kIndent, "ax = quot;", Util::kNewLine);
        out(kIndent, kIndent, "dx = rem;", Util::kNewLine);
        break;
    case 4:
        if (signedDiv) {
            out(kIndent, kIndent, "int64_t dividend = ((int64_t)edx << 32) | (int32_t)eax;", Util::kNewLine);
            out(kIndent, kIndent, "int32_t quot = (int32_t)(dividend / src);", Util::kNewLine);
            out(kIndent, kIndent, "int32_t rem = (int32_t)(dividend % src);", Util::kNewLine);
        } else {
            out(kIndent, kIndent, "uint64_t dividend = ((uint64_t)edx << 32) | eax;", Util::kNewLine);
            out(kIndent, kIndent, "dword quot = (dword)(dividend / src);", Util::kNewLine);
            out(kIndent, kIndent, "dword rem = (dword)(dividend % src);", Util::kNewLine);
        }

        out(kIndent, kIndent, "eax = quot;", Util::kNewLine);
        out(kIndent, kIndent, "edx = rem;", Util::kNewLine);
        break;
    default:
        assert(false);
        break;
    }

    out(kIndent, '}');
}

void COutput::outputShift(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& shiftCount = params[1];

    assert(dst.size);
    bool signedShift = instruction->type() == Token::T_SAR;
    auto typeInfo = getTypeInfo(dst.size);
    auto type = signedShift ? typeInfo.signedType : typeInfo.unsignedType;

    out('{', Util::kNewLine);

    out(kIndent, kIndent, type, " *dst = (", type, " *)&(");
    outputInstructionArgument(dst, shiftCount.address);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "dword shiftCount = (");
    outputInstructionArgument(shiftCount, dst.address, dst.size);
    out(") & 0x1f;", Util::kNewLine);

    out(kIndent, kIndent, "if (shiftCount) {", Util::kNewLine);
    out(kIndent, kIndent, kIndent, type, " res = *dst ");

    switch (instruction->type()) {
    case Token::T_SHL:
        out("<<");
        break;
    case Token::T_SHR:
    case Token::T_SAR:
        out(">>");
        break;
    default:
        assert(false);
        break;
    }

    out(" shiftCount;", Util::kNewLine);

    out(kIndent, kIndent, kIndent, "if (shiftCount <= ", typeInfo.bitCount, ')', Util::kNewLine);
    out(kIndent, kIndent, kIndent, kIndent, "g_flags.carry = (*dst >> (", typeInfo.bitCount, " - shiftCount)) & 1;", Util::kNewLine);
    out(kIndent, kIndent, kIndent, "else", Util::kNewLine);
    out(kIndent, kIndent, kIndent, kIndent, "g_flags.carry = 0;", Util::kNewLine);
    out(kIndent, kIndent, kIndent, "if (shiftCount == 1)", Util::kNewLine);
    out(kIndent, kIndent, kIndent, kIndent, "g_flags.overflow = ((*dst >> ", typeInfo.bitCount - 1, ") & 1)");
    if (instruction->type() == Token::T_SHL)
        out(" ^ ((*dst >> ", typeInfo.bitCount - 2, ") & 1)");
    out(';', Util::kNewLine);
    out(kIndent, kIndent, kIndent, "g_flags.sign = (res & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, kIndent, "g_flags.zero = res == 0;", Util::kNewLine);

    out(kIndent, kIndent, kIndent, "*dst = res;", Util::kNewLine);

    out(kIndent, kIndent, '}', Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputRotate(const Instruction *instruction)
{
    assert(instruction->numOperands() == 2);

    auto params = getOperandsInfo(instruction);

    const auto& dst = params[0];
    const auto& rotationCount = params[1];

    assert(dst.size);
    auto typeInfo = getTypeInfo(dst.size);

    out('{', Util::kNewLine);

    bool carryRotation = instruction->type() == Token::T_RCL || instruction->type() == Token::T_RCR;
    int mod = dst.size * 8 + (carryRotation != 0);

    out(kIndent, kIndent, typeInfo.unsignedType, " *dst = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(dst, rotationCount.address);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "dword rotationCount = ((");
    outputInstructionArgument(rotationCount, dst.address, dst.size);
    out(") & 0x1f) % ", mod, ';', Util::kNewLine);

    out(kIndent, kIndent, "if (rotationCount) {", Util::kNewLine);

    switch (instruction->type()) {
    case Token::T_RCL:
    case Token::T_ROL:
        out(kIndent, kIndent, kIndent, "dword newCarry = (*dst >> (", typeInfo.bitCount, " - rotationCount)) & 1;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "*dst = (*dst << rotationCount) | (*dst >> (", typeInfo.bitCount, " - rotationCount");
            if (instruction->type() == Token::T_RCL)
                out(" + 1) << 1) | g_flags.carry;", Util::kNewLine);
            else
                out("));", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "g_flags.carry = newCarry;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "if (rotationCount == 1)", Util::kNewLine);
        out(kIndent, kIndent, kIndent, kIndent, "g_flags.overflow = ((*dst & ", typeInfo.signMask, ") != 0) ^ g_flags.carry;", Util::kNewLine);
        break;
    case Token::T_RCR:
    case Token::T_ROR:
        out(kIndent, kIndent, kIndent, "if (rotationCount == 1)", Util::kNewLine);
        out(kIndent, kIndent, kIndent, kIndent, "g_flags.overflow = ((*dst & ", typeInfo.signMask, ") != 0) ^ g_flags.carry;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "int newCarry = (*dst >> (rotationCount - 1)) & 1;", Util::kNewLine);
        out(kIndent, kIndent, kIndent, "*dst = (*dst >> rotationCount) | ");
        if (instruction->type() == Token::T_RCR) {
            out("(g_flags.carry << (", typeInfo.bitCount, " - rotationCount)) | ((*dst >> 1) << (",
                typeInfo.bitCount, " - rotationCount + 1));", Util::kNewLine);
        } else {
            out("(*dst << (", typeInfo.bitCount, " - rotationCount));", Util::kNewLine);
        }
        out(kIndent, kIndent, kIndent, "g_flags.carry = newCarry;", Util::kNewLine);
        break;
    default:
        assert(false);
    }

    out(kIndent, kIndent, "}", Util::kNewLine);
    out(kIndent, "}");
}

void COutput::outputIntInOut(const Instruction *instruction)
{
    // TODO: implement debug break in place of int 3
    out("(void)0");
}

void COutput::outputNeg(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.signedType, " *dst = (", typeInfo.signedType, " *)&(");
    outputInstructionArgument(op);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.carry = *dst != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.overflow = *dst == ", typeInfo.signedMin, ';', Util::kNewLine);

    out(kIndent, kIndent, "*dst = -*dst;", Util::kNewLine);

    out(kIndent, kIndent, "g_flags.sign = (*dst & ", typeInfo.signMask, ") != 0;", Util::kNewLine);
    out(kIndent, kIndent, "g_flags.zero = *dst == 0;", Util::kNewLine);

    out(kIndent, '}');
}

void COutput::outputNot(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    out('{', Util::kNewLine);

    out(kIndent, kIndent, typeInfo.unsignedType, " *dst = (", typeInfo.unsignedType, " *)&(");
    outputInstructionArgument(op);
    out(");", Util::kNewLine);

    out(kIndent, kIndent, "*dst = ~*dst;", Util::kNewLine);
    out(kIndent, '}');
}

void COutput::outputLoop(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);
    assert(instruction->prefix().empty());

    outputConditionalJump(instruction, "--ecx");
}

void COutput::outputPushf(const Instruction *instruction)
{
    out("g_stack[--g_stackTop] = g_flags.carry | (g_flags.zero << 6) | (g_flags.sign << 7) | "
        "(g_flags.direction << 10) | (g_flags.overflow << 11)");
}

void COutput::outputPopf(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("pop(g_tmp.all);", Util::kNewLine);
    out(kIndent, "g_flags.carry = g_tmp.all & 1;", Util::kNewLine);
    out(kIndent, "g_flags.zero = (g_tmp.all >> 6) & 1;", Util::kNewLine);
    out(kIndent, "g_flags.sign = (g_tmp.all >> 7) & 1;", Util::kNewLine);
    out(kIndent, "g_flags.direction = (g_tmp.all >> 10) & 1;", Util::kNewLine);
    out(kIndent, "g_flags.overflow = (g_tmp.all >> 11) & 1");
}

void COutput::outputPusha(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("g_tmp.all = g_stackTop;", Util::kNewLine);
    out(kIndent, "push(eax);", Util::kNewLine);
    out(kIndent, "push(ecx);", Util::kNewLine);
    out(kIndent, "push(edx);", Util::kNewLine);
    out(kIndent, "push(ebx);", Util::kNewLine);
    out(kIndent, "push(g_tmp.all);", Util::kNewLine);
    out(kIndent, "push(ebp);", Util::kNewLine);
    out(kIndent, "push(esi);", Util::kNewLine);
    out(kIndent, "push(edi)");
}

void COutput::outputPopa(const Instruction *instruction)
{
    assert(instruction->numOperands() == 0);

    out("pop(edi);", Util::kNewLine);
    out(kIndent, "pop(esi);", Util::kNewLine);
    out(kIndent, "pop(ebp);", Util::kNewLine);
    out(kIndent, "g_stackTop++;", Util::kNewLine);
    out(kIndent, "pop(ebx);", Util::kNewLine);
    out(kIndent, "pop(edx);", Util::kNewLine);
    out(kIndent, "pop(ecx);", Util::kNewLine);
    out(kIndent, "pop(eax)");
}

void COutput::outputStc(const Instruction *instruction)
{
    out("g_flags.carry = true");
}

void COutput::outputClc(const Instruction *instruction)
{
    out("g_flags.carry = false");
}

void COutput::outputCld(const Instruction *instruction)
{
    out("g_flags.direction = false");
}

void COutput::outputSetz(const Instruction *instruction)
{
    assert(instruction->numOperands() == 1);

    auto params = getOperandsInfo(instruction);

    const auto& op = params[0];
    auto typeInfo = getTypeInfo(op.size);

    outputInstructionArgument(op);
    out(" = g_flags.zero != 0");
}

void COutput::outputConditionalJump(const Instruction *instruction, const char *condition /* = nullptr */)
{
    assert(instruction && instruction->isBranch() && instruction->numOperands() == 1);

    auto target = instruction->operands()[0].begin();

    if (target->type() == Token::T_SHORT)
        target = target->next();

    if (!target->text().startsWith('$')) {
        assert(target->next() == instruction->operands()[0].end());

        const auto& label = target->text();
        bool localLabel = label.startsWith('@');

        if (condition)
            out("if (", condition, ")", Util::kNewLine, kIndent, kIndent);

        if (localLabel || m_inProcLabels.present(target->text())) {
            if (target->text() == "return") {
                out("return;");
            } else {
                out("goto ");
                outputLabel(label);
            }
        } else {
            out("{ ");
            outputFunctionInvoke(label);
            out("; return; }");
        }
    }
}

void COutput::outputJmp(const Instruction *instruction)
{
    outputConditionalJump(instruction);
}

void COutput::outputJg(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.zero && g_flags.sign == g_flags.overflow");
}

void COutput::outputJge(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.sign == g_flags.overflow");
}

void COutput::outputJl(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.sign != g_flags.overflow");
}

void COutput::outputJz(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.zero");
}

void COutput::outputJnz(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.zero");
}

void COutput::outputJs(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.sign");
}

void COutput::outputJns(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.sign");
}

void COutput::outputJb(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.carry");
}

void COutput::outputJa(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.carry && !g_flags.zero");
}

void COutput::outputJnb(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.carry");
}

void COutput::outputJbe(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.carry || g_flags.zero");
}

void COutput::outputJle(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.zero || g_flags.sign != g_flags.overflow");
}

void COutput::outputJo(const Instruction *instruction)
{
    outputConditionalJump(instruction, "g_flags.overflow");
}

void COutput::outputJno(const Instruction *instruction)
{
    outputConditionalJump(instruction, "!g_flags.overflow");
}

// A hack for handling dynamic jump into a table of labels which are inside a proc, and tied within this proc
// (they jump into one another); there is no portable way to store goto label in table, and later jump to it.
auto COutput::checkForSwitchTable(OutputIterator it, const Instruction *instruction) -> OutputIterator
{
    if (instruction->type() == Token::T_MOV) {
        auto isOffset = instruction->operands()[1].begin()->type() == Token::T_OFFSET;
        if (isOffset) {
            auto address = instruction->operands()[1].begin()->next();
            assert(address != instruction->operands()[1].end());

            if (address->text() == kSwitchTableName) {
                while (it->next() != m_outputItems.end()) {
                    it = it->next();
                    if (it->type() == OutputItem::kInstruction) {
                        auto instruction = it->getItem<Instruction>();
                        if (instruction->type() == Token::T_JMP)
                            break;
                    }
                }

                static const char *kSwitchLines[] = {
                    "switch ((word)D0) {",
                    "case 0: goto nextEntry;",
                    "case 1: goto invisibleItem;",
                    "case 2: goto setPositions;",
                    "case 3: goto func1;",
                    "case 4: goto entryFrame;",
                    "case 5: goto sprite1;",
                    "case 6: goto invalidType;",
                    "case 7: goto func2;",
                    "case 8: goto stringEntry;",
                    "case 9: goto sprite2;",
                    "case 10: goto stringTable;",
                    "case 11: goto multiLineText;",
                    "case 12: goto number;",
                    "case 13: goto onSelectFireOnly;",
                    "case 14: goto onSelect;",
                    "case 15: goto beforeDrawFunc;",
                    "case 16: goto afterDrawFunc;",
                    "case 17: goto leftSkip;",
                    "case 18: goto rightSkip;",
                    "case 19: goto upSkip;",
                    "case 20: goto downSkip;",
                    "case 21: goto spriteCopy;",
                    "}",
                };

                for (const auto& line : kSwitchLines)
                    out(kIndent, line, Util::kNewLine);
            }
        }
    }

    return it;
}

// Remove switch table from data stream, it will be hard-coded into the code.
const OutputItem *COutput::checkForSwitchTable(const OutputItem *item, const DataItem *dataItem)
{
    if (dataItem->name() == kSwitchTableName)
        while (item->next() != m_outputItems.end() && item->next()->type() == OutputItem::kDataItem)
            item = item->next();

    return item;
}

void COutput::fillStructInfo()
{
    for (const auto& struc : m_structs) {
        const auto& structName = struc.name();
        char buf[256];
        structName.copy(buf);
        buf[structName.length()] = '.';

        size_t offset = 0;

        for (const auto& field : struc) {
            const auto& fieldName = field.name();

            auto nameLen = structName.length() + fieldName.length() + 1;
            assert(nameLen < sizeof(buf));

            fieldName.copy(buf + structName.length() + 1);

            if (field.elementSize()) {
                auto size = field.byteSize();
                m_structMap.add<size_t, size_t>(buf, nameLen, offset, size);
                offset += size;
            } else {
                auto nestedStruct = m_structs.findStruct(field.type());
                assert(nestedStruct);

                buf[nameLen++] = '.';
                size_t nestedStructOffset = 0;
                size_t unionSize = 0;

                for (const auto& field : *nestedStruct) {
                    const auto& fieldName = field.name();
                    assert(nameLen + fieldName.length() < sizeof(buf));

                    fieldName.copy(buf + nameLen);
                    m_structMap.add<size_t, size_t>(buf, nameLen + fieldName.length(),
                        offset + nestedStructOffset, 1u);

                    if (nestedStruct->isUnion())
                        unionSize = std::max(unionSize, field.byteSize());
                    else
                        nestedStructOffset += field.byteSize();
                }

                m_structMap.add<size_t, size_t>(buf, nameLen - 1, offset, nestedStructOffset);
                offset += nestedStructOffset + unionSize;
            }
        }

        m_structMap.add(structName, offset, offset);
    }

    m_structMap.seal();
}

void COutput::resetAutoDataIndex()
{
    m_dataIndex = m_index * kMaxAutoGeneratedItems;
}

bool COutput::isFinalRetn(const OutputItem& item)
{
    assert(item.type() == OutputItem::kInstruction && item.next() != m_outputItems.end());

    auto instruction = item.getItem<Instruction>();
    auto nextType = item.next()->type();

    return instruction->type() == Token::T_RETN &&
        (nextType == OutputItem::kEndProc || nextType == OutputItem::kProc || nextType == OutputItem::kDirective);
}

bool COutput::isLastLineEmpty() const
{
    auto doubleNewLineLen = 2 * Util::kNewLine.size();
    if (outputLength() < doubleNewLineLen)
        return false;

    return !memcmp(getOutputPtr() - doubleNewLineLen, Util::kNewLine.data(), Util::kNewLine.size())
        && !memcmp(getOutputPtr() - 2 * doubleNewLineLen, Util::kNewLine.data(), Util::kNewLine.size());
}

void COutput::outputOriginalInstructionComment(const Instruction *instruction, const char *start)
{
    addCommentPadding(start);

    auto prefixSpace = !instruction->prefix().empty() ? " " : "";
    out("// ", instruction->prefix(), prefixSpace, instruction->instructionText());
    if (instruction->hasOperands())
        out(' ');

    for (size_t i = 0; i < instruction->numOperands(); i++) {
        const auto& operand = instruction->operands()[i];
        const String *prev = nullptr;

        for (const auto& it : operand) {
            if (prev && Util::isId(prev->last()) && Util::isId(it.text().first()))
                out(' ');

            out(it.text());

            prev = &it.text();
        }

        if (lastOutputChar() == ' ')
            removeOutputChar(1);

        if (i != instruction->numOperands() - 1)
            out(", ");
    }

    out(Util::kNewLine);
}

void COutput::addCommentPadding(const char *start)
{
    constexpr int kCommentOffset = 44;

    auto lineLength = getLineLength(start);
    int fillLength = kCommentOffset - lineLength;

    // always output at least one space between semi-colon and comment
    do {
        out(' ');
    } while (--fillLength > 0);
}

size_t COutput::getLineLength(const char *start)
{
    auto end = getOutputPtr();

    for (auto p = end - 1; p >= start; p--) {
        if (*p == '\n') {
            start = p + 1;
            break;
        }
    }

    return end - start;
}

void COutput::outputComment(const String& comment, bool endWithNewLine /* = true */)
{
    for (size_t i = 0; i < comment.length(); i++) {
        if (comment[i] == ';')
            out("//");
        else
            out(comment[i]);
    }

    if (endWithNewLine)
        out(Util::kNewLine);
}

void COutput::outputFunctionInvoke(const String& target)
{
    auto isCallReg = [&]() {
        static const char *kRegs[] = { "ax", "bx", "cx", "dx", "si", "di", "bp" };

        if (target.length() != 3 || !target.startsWith('e'))
            return false;

        return std::find_if(std::begin(kRegs), std::end(kRegs), [&](const char *suffix) {
            return target[1] == suffix[0] && target[2] == suffix[1];
        }) != std::end(kRegs);
    };

    auto regIndex = amigaRegisterToIndex(target);
    if (regIndex >= 0 || isCallReg() || target.endsWith("Function"))
        out("((void (*)())(", target, "))()");
    else
        out(target, "()");
}

void COutput::initTableVariables()
{
    resetAutoDataIndex();

    const OutputItem *currentTableStart = nullptr;
    String tableStartSymbol;
    char buf[256];

    for (const auto& item : m_outputItems) {
        if (item.type() == OutputItem::kDataItem) {
            auto dataItem = item.getItem<DataItem>();
            auto name = dataItem->name();

            if (name.empty()) {
                auto len = getNextAutoVar(buf);
                assert(len < sizeof(buf));
                name.assign(buf, len);
            }

            if (dataItem->contiguous()) {
                if (!currentTableStart) {
                    currentTableStart = &item;
                    tableStartSymbol = name;
                } else {
                    if (tableStartSymbol != kSwitchTableName)
                        m_tableVarRanges.emplace_back(currentTableStart, &item);
                    currentTableStart = nullptr;
                }
            }
        }
    }
}

bool COutput::isTableVar(const OutputItem *item) const
{
    for (const auto& range : m_tableVarRanges)
        if (item >= range.first && item <= range.second)
            return true;

    return false;
}

int COutput::getGlobalTableIndex(int localIndex)
{
    assert(localIndex < kMaxTables);
    return m_index * kMaxTables + localIndex;
}

void COutput::outputInstructionArgument(const OperandInfo& op, bool assignAddress /* = false */, size_t defaultSize /* = 0 */)
{
    bool gotOffset = !op.offset.empty();

    if (op.pointer || gotOffset || op.dereference) {
        if (!op.address)
            out('*');

        auto size = op.size;
        if (!size)
            size = defaultSize;
        if (!size)
            size = 4;   // assume 32-bit if no size given

        auto sizeSpecifier = getTypeInfo(size).unsignedType;
        out('(', sizeSpecifier, " *)");
    } else if (assignAddress) {
        out("(void *)");
    }

    if (op.pointer || op.address || op.forceAddress || gotOffset) {
        if (gotOffset)
            out("((byte *)");

        if (!op.dereference || op.forceAddress)
            out('&');
    }

    outputToken(op.base, op.baseType);

    if (!op.offset.empty()) {
        out(" + ");
        outputToken(op.offset, op.offsetType);
    }

    if (!op.scale.empty())
        out(" * ", op.scale);

    if (!op.displacement.empty()) {
        out(" + ");
        outputToken(op.displacement, op.displacementType);
    }

    if (gotOffset)
        out(')');
}

void COutput::outputToken(const String& op, Token::Type type, bool isInstruction /* = true */)
{
    int startOffset = 0;

    switch (type) {
    case Token::T_HEX:
        if (op.startsWith('-')) {
            out('-');
            startOffset = 1;
        }
        out("0x", op.substr(startOffset).withoutLast());
        break;

    case Token::T_BIN:
        {
            int num = 0;

            for (size_t i = 0; i < op.length() - 1; i++)
                num = num * 2 + op[i] - '0';

            out(num);
        }
        break;

    case Token::T_STRING:
        if (isInstruction) {
            out(op);
        } else {
            out('"');
            for (size_t i = 1; i < op.length() - 1; i++) {
                if (op[i] == '\\')
                    out('\\');
                out(op[i]);
            }
            out('"');
        }
        break;

    default:
        out(op);
        break;
    }
}

void COutput::outputLabel(const String& label)
{
    if (label.startsWith("@@"))
        out("__", label.substr(2));
    else
        out(label);
}

auto COutput::getOperandsInfo(const Instruction *instruction) const -> InstructionOperandsInfo
{
    InstructionOperandsInfo result;
    static thread_local char convBuf[3][256];

    for (size_t i = 0; i < instruction->numOperands(); i++) {
        auto& opInfo = result[i];
        opInfo.size = instruction->operandSizes()[i];

        const auto& param = instruction->operands()[i];

        for (auto op = param.begin(); op != param.end(); op = op->next()) {
            assert(op < param.end());
            auto type = op->type();

            switch (type) {
            case Token::T_OFFSET:
                opInfo.address = true;
                assert(opInfo.base.empty());
                break;
            case Token::T_LBRACKET:
                opInfo.dereference = true;
                break;
            case Token::T_BYTE:
            case Token::T_WORD:
            case Token::T_DWORD:
                opInfo.pointer = true;
                break;
            case Token::T_PTR:
            case Token::T_RBRACKET:
            case Token::T_LPAREN:
            case Token::T_RPAREN:
            case Token::T_PLUS:
                // skip over
                break;
            case Token::T_MULT:
                op = op->next();

                if (opInfo.scale.empty()) {
                    opInfo.scale = op->text();
                } else {
                    // only one special case
                    static thread_local char buf[128];
                    opInfo.scale.copy(buf);
                    memcpy(buf + opInfo.scale.length(), " * ", 3);
                    op->text().copy(buf + opInfo.scale.length() + 3);

                    opInfo.scale = String(buf, opInfo.scale.length() + 3 + op->text().length());
                }

                assert(op->type() == Token::T_NUM);
                assert(op->next() == param.end() || op->next()->type() != Token::T_PLUS);
                break;
            default:
                bool forceSearch = false;
                if (type == Token::T_SIZE) {
                    op = op->next();
                    assert(op->type() == Token::T_ID);
                    forceSearch = true;
                    type = Token::T_ID;
                }
                if (type == Token::T_ID || type == Token::T_STRING || op->isRegister() || op->isNumber()) {
                    if (opInfo.base.empty()) {
                        opInfo.base = expandStructField(op, opInfo, convBuf[i], forceSearch);
                        opInfo.baseType = type;
                        if (op->isRegister())
                            opInfo.straightReg = true;
                        if (type == Token::T_ID && op != param.end() && op->next()->type() == Token::T_LBRACKET)
                            opInfo.forceAddress = true;
                    } else if (opInfo.offset.empty()) {
                        opInfo.offset = expandStructField(op, opInfo, convBuf[i], forceSearch);
                        opInfo.offsetType = type;
                    } else if (opInfo.displacement.empty()) {
                        opInfo.displacement = expandStructField(op, opInfo, convBuf[i], forceSearch);
                        opInfo.displacementType = type;
                    } else {
                        assert(false);
                    }
                    assert(opInfo.base.length() < sizeof(convBuf[0]) && opInfo.offset.length() < sizeof(convBuf[0]) &&
                        opInfo.displacement.length() < sizeof(convBuf[0]));
                }
                break;
            }
        }

        if (opInfo.straightReg && (opInfo.address || opInfo.dereference || opInfo.pointer || !opInfo.displacement.empty() ||
            !opInfo.offset.empty() || !opInfo.scale.empty()))
            opInfo.straightReg = false;
    }

    ensureSizeInformation(instruction, result);

    assert(result[0].size | result[1].size | result[2].size);
    assert(instruction->type() == Token::T_MOVZX || instruction->type() == Token::T_SHL || instruction->type() == Token::T_RCR ||
        instruction->type() == Token::T_RCL || instruction->type() == Token::T_ROL || instruction->type() == Token::T_ROR ||
        instruction->type() == Token::T_SAR ||
        std::accumulate(result.begin(), result.end(), 0, [](int sum, const auto& op) { return sum + op.size; }) %
        std::count_if(result.begin(), result.end(), [](const auto& op) { return op.size > 0; }) == 0);

    fixLocalVariableAccess(result);

    return result;
}

void COutput::fixLocalVariableAccess(InstructionOperandsInfo& opInfo) const
{
    if (opInfo[1].base == "esp") {
        if (opInfo[1].offsetType == Token::T_ID)
            opInfo[1].base = opInfo[1].offset;
        else if (opInfo[1].displacementType == Token::T_ID)
            opInfo[1].base = opInfo[1].displacement;
        else
            assert(false);

        opInfo[1].offset.clear();
        opInfo[1].displacement.clear();
    }
}

void COutput::ensureSizeInformation(const Instruction *instruction, InstructionOperandsInfo& opInfo) const
{
    assert(!instruction->isShiftRotate() || instruction->numOperands() == 2);

    auto numKnownSizeOperands = std::count_if(opInfo.begin(), opInfo.end(), [](const auto& op) {
        return op.size > 0;
    });

    bool doThoroughSearch = instruction->isShiftRotate() && !opInfo.begin()->size || numKnownSizeOperands == 0;

    // only do more thorough search if simpler methods failed
    if (doThoroughSearch) {
        for (auto& op : opInfo) {
            if (op.baseType == Token::T_ID) {
                auto regIndex = amigaRegisterToIndex(op.base);
                if (regIndex >= 0) {
                    op.size = 4;
                    break;
                } else {
                    auto id = op.base;

                    auto dotIndex = op.base.indexOf('.');
                    if (dotIndex >= 0)
                        id = id.substr(0, dotIndex);

                    auto type = m_references.getType(id);
                    switch (type.first) {
                    case References::kByte:
                        op.size = 1;
                        return;
                    case References::kWord:
                        op.size = 2;
                        return;
                    case References::kDword:
                        op.size = 4;
                        return;
                    case References::kTbyte:
                        op.size = 10;
                        return;
                    case References::kUser:
                        {
                            assert(dotIndex >= 0);

                            auto fieldName = op.base.substr(dotIndex + 1);
                            op.size = getStructVariableSize(type.second, fieldName);
                            return;
                        }
                    case References::kIgnore:
                        return;
                    default:
                        assert(false);
                    }
                }
            }
        }
    }

    overrideOrPropagateStructVarSize(opInfo);
}

void COutput::overrideOrPropagateStructVarSize(InstructionOperandsInfo& opInfo) const
{
    if (opInfo[0].size != opInfo[1].size || !opInfo[0].size) {
        for (int i = 0; i < 2; i++) {
            auto otherOp = i ^ 1;
            if (opInfo[i].structField) {
                if (opInfo[otherOp].straightReg) {
                    opInfo[i].size = opInfo[otherOp].size;
                    break;
                } else if (opInfo[otherOp].baseType == Token::T_NUM) {
                    opInfo[otherOp].size = opInfo[i].size;
                    break;
                }
            }
        }
    }
}

size_t COutput::getStructVariableSize(const String& structName, const String& fieldName) const
{
    assert(!structName.empty() && !fieldName.empty());

    char structNameAndField[256];
    assert(structName.length() + fieldName.length() + 1 < sizeof(structNameAndField));

    structName.copy(structNameAndField);
    structNameAndField[structName.length()] = '.';
    fieldName.copy(structNameAndField + structName.length() + 1);

    size_t len = structName.length() + fieldName.length() + 1;
    auto offsetAndSize = m_structMap.get(structNameAndField, len);

    assert(offsetAndSize);
    return offsetAndSize->size();
}

String COutput::expandStructField(Iterator::Iterator<const Instruction::Operand>& op,
    OperandInfo& opInfo, char *dest, bool forceSearch /* = false */) const
{
    if (op->type() == Token::T_ID && (forceSearch || op->text().contains('.'))) {
        if (auto field = m_structMap.get(op->text())) {
            if (!opInfo.size && !opInfo.pointer && opInfo.dereference)
                opInfo.size = std::min<int>(field->size(), 4);

            auto offset = field->offset();

            if (op->next()->type() == Token::T_PLUS) {
                op = op->next()->next();
                assert(op->isNumber());
                offset += op->text().toInt();
            }

            _itoa(offset, dest, 10);

            if (opInfo.dereference)
                opInfo.structField = true;

            return { dest, strlen(dest) };
        } else {
            int dotIndex = op->text().indexOf('.');
            if (dotIndex >= 0) {
                const auto& var = op->text().substr(0, dotIndex);

                if (auto structName = m_globalStructVars->get(var)) {
                    const auto& field = op->text().substr(dotIndex + 1);

                    size_t len = sprintf(dest, "((%.*s *)&%.*s)->%.*s", structName->length(), structName->data(),
                        var.length(), var.data(), field.length(), field.data());

                    opInfo.structField = true;
                    opInfo.size = getStructFieldSize(*structName, field);

                    return { dest, len };
                }
            }
        }
    } else if (op->text().length() > 3 && op->text()[2] == ':' && op->text()[1] == 's') {
        return op->text().substr(3);
    }

    return op->text();
}

size_t COutput::getStructFieldSize(const PascalString& structName, const String& field) const
{
    auto len = structName.length() + field.length() + 1;

    char buf[512];
    assert(len + 1 < sizeof(buf));

    structName.copy(buf);
    buf[structName.length()] = '.';
    field.copy(buf + structName.length() + 1);
    buf[len] = '\0';

    auto sizeRef = m_structMap.get(buf, len);
    assert(sizeRef);

    return sizeRef ? sizeRef->size() : 0;
}

size_t COutput::getNextAutoVar(char *destBuffer)
{
    return sprintf(destBuffer, kAutoVarPrefix "%05d", m_dataIndex++);
}

auto COutput::getTypeInfo(size_t size) -> TypeInfo
{
    size = size ? size : 4;

    switch (size) {
    case 1: return { "byte", "int8_t", "int16_t", 8, "0x80", "INT8_MIN", "INT8_MAX" };
    case 2: return { "word", "int16_t", "int32_t", 16, "0x8000", "INT16_MIN", "INT16_MAX" };
    case 4: return { "dword", "int32_t", "int64_t", 32, "0x80000000", "INT32_MIN", "INT32_MAX" };
    case 8: return { "uint64_t", "int64_t", nullptr, 64, "0x8000000000000000", "INT64_MIN", "INT64_MAX" };
    default: assert(false); return {};
    };
}
