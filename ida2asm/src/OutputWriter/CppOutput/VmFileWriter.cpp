#include "Struct.h"
#include "OutputException.h"
#include "SymbolFileParser.h"
#include "VmFileWriter.h"

#define kVmStackSize "1024"

VmFileWriter::VmFileWriter(const std::string& baseDir, int extraMemorySize, const SymbolFileParser& symFileParser,
    const DataBank& dataBank, const StructStream& structs)
:
    m_baseDir(baseDir), m_extendedMemorySize(extraMemorySize),
    m_symFileParser(symFileParser), m_dataBank(dataBank), m_structs(structs)
{
    m_extendedMemorySize = (m_extendedMemorySize + 7) & ~7;
}

void VmFileWriter::outputVmFiles()
{
    outputCppFile();
    outputHeaderFile();
}

void VmFileWriter::outputCppFile()
{
    constexpr char kVmCppFileContents[] =
        "Register A0, A1, A2, A3, A4, A5, A6, D0, D1, D2, D3, D4, D5, D6, D7;\n"
        "\n"
        "namespace SwosVM {\n"
        "\n"
        "Flags flags;\n"
        "Register eax, ebx, ecx, edx, esi, edi, ebp, tmp;\n"
        "\n"
        "// place 68k registers near x86 ones (hopefully!) to use the cache better\n"
        "int32_t stack[" kVmStackSize "];\n"
        "int32_t stackTop = sizeofarray(stack);\n\n";

    xfopen(kCppFilename);

    xfputs("//" kAutoGeneratedWarningText "\n\n");
    xfputs("#include \"");
    xfputs(kHeaderFilename);
    xfputs("\"\n\n");

    xfwrite(kVmCppFileContents, sizeof(kVmCppFileContents) - 1);

    outputMemoryArray();
    outputProcExterns();
    outputProcVector();
    outputProcFunctions();
    outputMemoryAccessFunctions();
    outputDebugFunctions();

    xfputs("}\n");

    xfclose();
}

void VmFileWriter::outputHeaderFile()
{
    constexpr char kVmHeaderContentsPart1[] =
        "// " kAutoGeneratedWarningText "\n\n"
        "#pragma once\n\n"

        "#include \"swos.h\"\n\n"

        "namespace SwosVM {\n\n"

        "constexpr int kNum68kRegisters = 15;\n"
        "constexpr int k68kRegisterTotalSize = kNum68kRegisters * 4;"
        "using RegisterSet68k = std::array<Register, kNum68kRegisters>;\n\n"

        "inline void store68kRegistersTo(RegisterSet68k& regs)\n"
        "{\n"
        "    regs[0] = A0; regs[1] = A1; regs[2] = A2; regs[3] = A3;\n"
        "    regs[4] = A4; regs[5] = A5; regs[6] = A6; regs[7] = D0;\n"
        "    regs[8] = D1; regs[9] = D2; regs[10] = D3; regs[11] = D4;\n"
        "    regs[12] = D5; regs[13] = D6; regs[14] = D7;\n"
        "}\n"
        "\n"
        "inline void load68kRegistersFrom(const RegisterSet68k& regs)\n"
        "{\n"
        "    A0 = regs[0]; A1 = regs[1]; A2 = regs[2]; A3 = regs[3];\n"
        "    A4 = regs[4]; A5 = regs[5]; A6 = regs[6]; D0 = regs[7];\n"
        "    D1 = regs[8]; D2 = regs[9]; D3 = regs[10]; D4 = regs[11];\n"
        "    D5 = regs[12]; D6 = regs[13]; D7 = regs[14];\n"
        "}\n\n"

        "struct Flags\n"
        "{\n"
        "    bool carry;\n"
        "    bool zero;\n"
        "    bool sign;\n"
        "    bool overflow;\n"
        "};\n"
        "\n"
        "//    SWOS VM memory layout:\n"
        "//    +---------------+\n"
        "//    |   safe area   |\n"
        "//    +---------------+\n"
        "//    |   basic mem   |    (all the variables)\n"
        "//    +---------------+\n"
        "//    |   safe area   |\n"
        "//    +---------------+\n"
        "//    |  extended mem |    (memory the game allocates from the OS)\n"
        "//    +---------------+\n"
        "//    |   safe area   |\n"
        "//    +---------------+\n"
        "//    | pointer pool  |    (native pointers, pointing outside the SWOS VM)\n"
        "//    |     area      |\n"
        "//    +---------------+\n"
        "//    |   safe area   |\n"
        "//    +---------------+\n"
        "//    |  dynamic mem  |    (memory allocated by the code outside the SWOS VM)\n"
        "//    |  (allocated)  |\n"
        "//    +---------------+\n"
        "//    |   safe area   |\n"
        "//    +---------------+\n";

    constexpr char kVmHeaderContentsPart2[] = "\n"
        "extern Register eax, ebx, ecx, edx, esi, edi, ebp, tmp;\n"
        "extern Flags flags;\n"
        "extern int32_t stack[" kVmStackSize "];\n"
        "extern int32_t stackTop;\n\n"
        "extern word * const g_memWord;\n"
        "extern dword * const g_memDword;\n"
        "extern SwosVariables * const vars;\n"
        "#define swos (*SwosVM::vars)\n\n"

        "#ifndef sizeofarray\n"
        "# define sizeofarray(a) (sizeof(a) / sizeof((a)[0]))\n"
        "#endif\n\n"

        "size_t readMemory(dword addr, size_t size);\n"
        "void writeMemory(dword addr, size_t size, size_t value);\n"
        "char *offsetToPtr(dword offset);\n"
        "char *getExtraMemoryArea();\n"
        "SwosDataPointer<char> allocateMemory(size_t size);\n"
        "SwosDataPointer<char> allocateString(const char *str);\n"
        "SwosDataPointer<char> cacheString(const char *str);\n"
        "void resetStringCache(dword mark);\n"
        "void releaseMemory(dword mark);\n"
        "dword getMemoryMark();\n"
        "dword registerPointer(const void *ptr);\n"
        "dword getPointerPoolMark();\n"
        "void releasePointers(dword mark);\n\n"

        "using VoidFunction = void (*)();\n"
        "VoidFunction fetchProc(int index);\n"
        "void invokeProc(int index);\n"
        "int registerProc(VoidFunction proc);\n"
        "dword getProcMark();\n"
        "void releaseProcs(dword mark);\n\n"

        "using MemoryMark = std::tuple<dword, dword, dword, dword>;\n"
        "MemoryMark markAllMemory();\n"
        "void releaseAllMemory(const MemoryMark& mark);\n"
        "bool isExternalPointer(dword addr);\n\n"

        "#ifdef DEBUG\n"
        "# ifndef debugBreak\n"
        "void debugBreak();\n"
        "# endif\n"
        "void initSafeMemoryAreas();\n"
        "void verifySafeMemoryAreas();\n"
        "#else\n"
        "# ifndef debugBreak\n"
        "#  define debugBreak()\n"
        "# endif\n"
        "static inline void initSafeMemoryAreas() {}\n"
        "static inline void verifySafeMemoryAreas() {}\n"
        "#endif\n\n"

        "# define push(a) (stack[--stackTop] = (a))\n"
        "# define pop(a) ((a) = stack[stackTop++])\n\n"

        "static uint16_t& ax = eax.lo16;\n"
        "static uint16_t& bx = ebx.lo16;\n"
        "static uint16_t& cx = ecx.lo16;\n"
        "static uint16_t& dx = edx.lo16;\n"
        "static uint16_t& si = esi.lo16;\n"
        "static uint16_t& di = edi.lo16;\n"
        "static uint16_t& bp = ebp.lo16;\n"
        "static uint8_t& ah = eax.hi8;\n"
        "static uint8_t& al = eax.lo8;\n"
        "static uint8_t& bh = ebx.hi8;\n"
        "static uint8_t& bl = ebx.lo8;\n"
        "static uint8_t& ch = ecx.hi8;\n"
        "static uint8_t& cl = ecx.lo8;\n"
        "static uint8_t& dh = edx.hi8;\n"
        "static uint8_t& dl = edx.lo8;\n\n"

        "inline bool isSwosPtr(const void *inPtr) {\n"
        "    auto ptr = reinterpret_cast<const uint8_t *>(inPtr);\n"
        "    return ptr >= g_memByte + kSafeMemAreaSize && ptr + 4 <= g_memByte + kMemSize - kSafeMemAreaSize;\n"
        "}\n"
        "\n"
        "inline dword ptrToOffset(const void *ptr) {\n"
        "    assert(!ptr || ptr == kSentinel || isSwosPtr(ptr));\n"
        "\n"
        "    if (!ptr)\n"
        "        return 0;\n"
        "\n"
        "    if (ptr == kSentinel)\n"
        "        return -1;\n"
        "\n"
        "    return reinterpret_cast<const uint8_t *>(ptr) - g_memByte;\n"
        "}\n"
        "\n";

    xfopen(kHeaderFilename);

    constexpr int kPointerPoolSize = 32 * 8;
    constexpr int kDynamicMemSize = 1024;

    xfwrite(kVmHeaderContentsPart1, sizeof(kVmHeaderContentsPart1) - 1);

    xfprintf("\n"
        "constexpr size_t kSafeMemAreaSize = %u;\n"
        "constexpr size_t kMemStartOfs = kSafeMemAreaSize;\n"
        "constexpr size_t kBasicMemSize = %u;\n"
        "constexpr size_t kPointerPoolSize = %u;\n"
        "constexpr size_t kExtendedMemSize = %u;\n"
        "constexpr size_t kDynamicMemSize = %u;\n"
        "constexpr size_t kMemSize = kBasicMemSize + kPointerPoolSize + kExtendedMemSize + kDynamicMemSize + 5 * kSafeMemAreaSize;\n\n",
        DataBank::zeroRegionSize(), memArraySize(), kPointerPoolSize, m_extendedMemorySize, kDynamicMemSize);

    const int kMemSizes[] = {
        static_cast<int>(DataBank::zeroRegionSize()), static_cast<int>(memArraySize()), kPointerPoolSize, m_extendedMemorySize, kDynamicMemSize
    };
    for (auto size : kMemSizes)
        xfprintf("static_assert(%u %% sizeof(void *) == 0, \"Run to the Hills\");\n", size);

    xfputs("\nextern uint8_t g_memByte[kMemSize];\n");

    xfputs("\n"
        "static uint8_t * const kMemStart = g_memByte + kSafeMemAreaSize;\n"
        "static uint8_t * const kExtendedMemStart = kMemStart + kBasicMemSize + kSafeMemAreaSize;\n"
        "static uint8_t * const kPointerPoolStart = kExtendedMemStart + kExtendedMemSize + kSafeMemAreaSize;\n"
        "static uint8_t * const kDynamicMemStart = kPointerPoolStart + kPointerPoolSize + kSafeMemAreaSize;\n\n");

    outputVariablesStruct();
    outputVariablesEnum();
    outputProcIndices();

    xfwrite(kVmHeaderContentsPart2, sizeof(kVmHeaderContentsPart2) - 1);
    xfputs("}\n");
    xfclose();
}

void VmFileWriter::outputVariablesStruct()
{
    xfputs("#pragma pack(push, 1)\n"
        "struct SwosVariables\n{\n");

    size_t lastOffset = 0;
    size_t anonCounter = 0;

    auto outputVar = [&](const auto& var, const auto *next) {
        assert(!var.name || var.offset + var.alignment >= lastOffset);

        bool skipNext = false;

        if (var.exportedDecl) {
            const auto& decl = var.exportedDecl;

            if (var.offset > lastOffset) {
                auto fillSize = var.offset - lastOffset;
                xfprintf("    byte filler__%04u[%u];\n", anonCounter++, fillSize);
            }

            auto byteSkip = std::max<int>(var.size, var.exportedSize) * var.dup;

            if (decl.endsWith("()")) {
                assert(decl.startsWith("void (*"));
                xfprintf("    SwosProcPointer %.*s;\n", var.name.length(), var.name.data());
            } else if (decl.contains('*')) {
                byteSkip = outputPointerVariable(var, byteSkip);
            } else if (decl.endsWith("[]")) {
                auto arraySize = var.type == DataBank::kString ? byteSkip : var.dup;

                char lenBuf[128];
                lenBuf[0] = '\0';

                if (var.type == DataBank::kString && next && !next->name && next->type == DataBank::kInt &&
                    next->size == 1 && next->dup == 1 && !next->intValue) {
                    arraySize++;
                    byteSkip++;
                    skipNext = true;
                } else if (var.type == DataBank::kOffset) {
                    arraySize = 1;
                }

                arraySize = std::max<size_t>(arraySize, 1);
                _itoa(arraySize, lenBuf, 10);

                xfprintf("    %.*s[%s];\n", decl.length() - 2, decl.data(), lenBuf);
            } else {
                if (var.exportedArraySize >= 0) {
                    if (var.dup > 1) {
                        if (var.exportedArraySize != var.dup)
                            throw OutputException("exported array size mismatch for variable `"s + var.name.string() +
                                "', " + std::to_string(byteSkip) + " vs " + std::to_string(var.exportedArraySize) +
                                " (exported)", m_filename);
                    } else {
                        byteSkip = var.exportedArraySize * var.exportedSize;
                    }
                } else if (auto structName = m_dataBank.structNameFromVar(var.name)) {
                    auto structSize = m_structs.getStructSize(structName->string());
                    byteSkip = structSize;
                }

                xfprintf("    %.*s;\n", decl.length(), decl.data());
            }

            lastOffset = var.offset + byteSkip;
        }

        return skipNext;
    };

    m_dataBank.traverseVars(outputVar);

    xfputs(
        "};\n"
        "#pragma pack(pop)\n"
    );
}

void VmFileWriter::outputVariablesEnum()
{
    xfputs("\nenum class Offsets : dword\n{\n");
    const DataBank::Var *lastVar = nullptr;

    std::vector<const DataBank::Var *> varsToCheck;
    varsToCheck.reserve(32);
    int varOrd = 0;

    m_dataBank.traverseVars([&](const auto& var) {
        if (var.exportedDecl) {
            lastVar = &var;
            if (varOrd++ % 16 == 0)
                varsToCheck.push_back(&var);

            xfprintf("    %.*s = %u,\n", var.name.length(), var.name.data(), var.offset);
        }
    });
    xfputs("};\n\n");

    assert(lastVar);
    if (varsToCheck.back() != lastVar)
        varsToCheck.push_back(lastVar);

    for (auto var : varsToCheck)
        xfprintf("static_assert(offsetof(SwosVariables, %.*s) == %u, \"Variable offsets are broken\");\n",
            var->name.length(), var->name.data(), var->offset);
}

void VmFileWriter::outputProcIndices()
{
    xfputs("\nenum class Procs : int\n{\n");
    m_dataBank.traverseProcs([this] (const auto& procName, bool, int index) {
        xfprintf("    %.*s = %d,\n", procName.length(), procName.data(), index);
    });
    xfputs("};\n");
}

size_t VmFileWriter::outputPointerVariable(const DataBank::Var& var, size_t byteSkip)
{
    const auto& decl = var.exportedDecl;

    assert(!decl.empty() && decl.contains('*'));

    int indirections = 1;
    int firstStarIndex = decl.indexOf('*');
    int name = firstStarIndex + 1;

    if (name >= 0) {
        while (name < static_cast<int>(decl.length()) && decl[name] == '*') {
            name++;
            indirections++;
        }

        if (name >= static_cast<int>(decl.length()))
            throw OutputException("invalid expression for exported variable " + var.name.string(), m_filename);

        if (!Util::isId(decl[name]))
            throw OutputException("expression too complex for exported variable " + var.name.string(), m_filename);
    }

    char buf[256] = "    ";
    constexpr char kSwosDataPointer[] = "SwosDataPointer<";
    size_t j = 4;

    assert(decl.length() + j * indirections + 1 < sizeof(buf));

    for (int i = 0; i < indirections; i++) {
        memcpy(buf + j, kSwosDataPointer, sizeof(kSwosDataPointer) - 1);
        j += sizeof(kSwosDataPointer) - 1;
    }

    while (firstStarIndex > 1 && Util::isSpace(decl[firstStarIndex - 1]))
        firstStarIndex--;

    memcpy(buf + j, decl.data(), firstStarIndex);
    j += firstStarIndex;

    for (int i = 0; i < indirections; i++)
        buf[j++] = '>';

    buf[j++] = ' ';

    const auto& nameSubstr = decl.substr(name);
    nameSubstr.copy(buf + j);
    j += nameSubstr.length();

    if (decl.endsWith("[]")) {
        buf[j - 1] = '1';
        buf[j++] = ']';
        byteSkip = 4;
    }

    strcpy(buf + j, ";\n");
    xfputs(buf);

    assert(j < sizeof(buf));

    if (var.dup == 1 && var.exportedArraySize > 0)
        byteSkip *= var.exportedArraySize;

    return byteSkip;
}

void VmFileWriter::outputMemoryArray()
{
    assert(m_f && memArraySize() % 4 == 0);

    const auto& length = Util::formatDelimitedNumber(m_dataBank.memoryByteSize(), '\'');
    const auto& lengthRounded = Util::formatDelimitedNumber(memArraySize(), '\'');

    xfprintf("// byte size: %s (rounded: %s), additional memory allocated: %u\n",
        length.c_str(), lengthRounded.c_str(), m_extendedMemorySize);
    xfprintf("alignas(%u) uint8_t g_memByte[kMemSize] = {", sizeof(void *));

    outputZeroMemoryRegion();
    size_t offset = DataBank::zeroRegionSize();

    auto outputVar = [this, &offset](const auto& var, const auto *) {
        xfputs("\n    ", true);

        assert(!var.name || var.offset == offset + var.alignment && m_dataBank.getVarOffset(var.name) == var.offset);
        assert(!var.exportedDecl || var.type == DataBank::kString ||
            var.offset % (var.type == DataBank::kStruct ? 4 : std::min<uint32_t>(var.size, 4)) == 0 ||
            std::get<3>(m_symFileParser.exportedDeclaration(var.name)) == 1);

        outputComment(var.leadingComment);
        if (!var.leadingComment.empty())
            xfputs("\n    ", true);

        for (size_t i = 0; i < var.alignment; i++)
            outputInt(0, 1);

        switch (var.type) {
        case DataBank::kInt:
            for (size_t i = 0; i < var.dup; i++)
                outputInt(var.intValue, std::min(var.size, 4u));
            break;
        case DataBank::kString:
            assert(var.dup == 1);
            outputString(var);
            break;
        case DataBank::kOffset:
            outputOffset(var);
            break;
        case DataBank::kStruct:
            for (size_t i = 0; i < var.size * var.dup; i++)
                outputInt(0, 1);
            break;
        default:
            assert(false);
        }

        outputOriginalValue(var, offset);
        offset += var.size * var.dup + var.alignment;

        return false;
    };

    m_dataBank.traverseVars(outputVar);

    xfputs("\n};\n\n");

    xfputs("SwosVariables * const vars = reinterpret_cast<SwosVariables *>(g_memByte);\n");
    xfputs("word * const g_memWord = reinterpret_cast<word *>(g_memByte);\n");
    xfputs("dword * const g_memDword = reinterpret_cast<dword *>(g_memByte);\n");
}

void VmFileWriter::outputProcExterns()
{
    xfputs("}\n\n");

    m_dataBank.traverseProcs([this](const auto& procName, bool imported, int) {
        xfprintf("extern void %s%.*s();\n", imported ? "SWOS::" : "", procName.length(), procName.data());
    });

    xfputs("\n\nnamespace SwosVM {\n\n");
}

void VmFileWriter::outputProcVector()
{
    xfprintf("static void (*kProcs[%u])() = {", m_dataBank.numProcPointers());

    m_dataBank.traverseProcs([this](const auto& procName, bool imported, int) {
        xfprintf("\n    %s%.*s,", imported ? "SWOS::" : "", procName.length(), procName.data());
    });

    xfputs("\n};\n");
}

void VmFileWriter::outputProcFunctions()
{
    const char kInvokeProcFunction[] = "\n"
        "constexpr size_t kNumProcs = sizeof(kProcs) / sizeof(kProcs[0]);\n"
        "static std::vector<VoidFunction> m_userProcs;\n"
        "\n"
        "VoidFunction fetchProc(int index)\n"
        "{\n"
        "    assert(index <= 0 && index >= -static_cast<int>(kNumProcs + m_userProcs.size() + 1));\n"
        "\n"
        "    if (index > -2 || index < -static_cast<int>(kNumProcs + m_userProcs.size()) - 1)\n"
        "        return nullptr;\n"
        "\n"
        "    index = -(index + 2);\n"
        "    return index >= kNumProcs ? m_userProcs[index - kNumProcs] : kProcs[index];\n"
        "}\n"
        "\n"
        "void invokeProc(int index)\n"
        "{\n"
        "    auto proc = fetchProc(index);\n"
        "    if (proc)\n"
        "        proc();\n"
        "}\n"
        "\n"
        "int registerProc(VoidFunction proc)\n"
        "{\n"
        "    assert(proc);\n"
        "\n"
        "    auto it = std::find(m_userProcs.begin(), m_userProcs.end(), proc);\n"
        "\n"
        "    if (it != m_userProcs.end())\n"
        "        return -2 - (it - m_userProcs.begin()) - static_cast<int>(kNumProcs);\n"
        "\n"
        "    m_userProcs.push_back(proc);\n"
        "    return -1 - static_cast<int>(m_userProcs.size()) - static_cast<int>(kNumProcs);\n"
        "}\n"
        "\n"
        "dword getProcsMark()\n"
        "{\n"
        "    return m_userProcs.size();\n"
        "}\n"
        "\n"
        "void releaseProcs(dword mark)\n"
        "{\n"
        "    assert(mark <= m_userProcs.size());\n"
        "    m_userProcs.resize(mark);\n"
        "}\n";

    xfputs(kInvokeProcFunction);
}

void VmFileWriter::outputMemoryAccessFunctions()
{
    const char kMemFunctions[] = "\n"
        "constexpr dword kExternalPointerMask = 1 << 31;\n"
        "SDL_UNUSED constexpr size_t kMaxPointers = kPointerPoolSize / sizeof(void *);\n"
        "const auto kPointerPool = reinterpret_cast<char **>(kPointerPoolStart);\n"
        "\n"
        "static size_t m_numPointers;\n"
        "static std::vector<std::pair<const char *, dword>> m_stringCache;\n"
        "\n"
        "static size_t readExternalPointer(size_t index, size_t size)\n"
        "{\n"
        "    assert(index < m_numPointers);\n"
        "\n"
        "    auto ptr = kPointerPool[index];\n"
        "    // trust the compiler that the pointers are aligned\n"
        "    switch (size) {\n"
        "    case 1: return *reinterpret_cast<const uint8_t *>(ptr);\n"
        "    case 2: return *reinterpret_cast<const uint16_t *>(ptr);\n"
        "    case 4: return *reinterpret_cast<const uint32_t *>(ptr);\n"
        "    default:\n"
        "        assert(false);\n"
        "        return 0;\n"
        "    }\n"
        "}\n"
        "\n"
        "size_t readMemory(dword addr, size_t size)\n"
        "{\n"
        "    if (addr & kExternalPointerMask)\n"
        "        return readExternalPointer(addr & ~kExternalPointerMask, size);\n"
        "\n"
        "    assert(size == 1 || size == 2 || size == 4);\n"
        "    assert(addr >= kMemStartOfs && addr + size <= kMemSize);\n"
        "\n"
        "    if (size == 1)\n"
        "        return g_memByte[addr];\n"
        "\n"
        "    switch (addr % size) {\n"
        "    case 0:\n"
        "        return size == 2 ? g_memWord[addr / 2] : g_memDword[addr / 4];\n"
        "        break;\n"
        "    case 1:\n"
        "        if (size == 2)\n"
        "            return g_memByte[addr] | (g_memByte[addr + 1] << 8);\n"
        "        else\n"
        "            return (g_memDword[(addr - 1) / 4] >> 8) | (g_memByte[addr + 3] << 24);\n"
        "        break;\n"
        "    case 2:\n"
        "        return g_memWord[addr / 2] | (g_memWord[addr / 2 + 1] << 16);\n"
        "        break;\n"
        "    case 3:\n"
        "        return g_memByte[addr] | (g_memDword[(addr + 1) / 4] << 8);\n"
        "        break;\n"
        "    default:\n"
        "        assert(false);\n"
        "        return 0;\n"
        "    }\n"
        "}\n"
        "\n"
        "void writeMemory(dword addr, size_t size, size_t value)\n"
        "{\n"
        "    assert(size == 1 || size == 2 || size == 4);\n"
        "    assert(addr >= kMemStartOfs && addr + size <= kMemSize);\n"
        "\n"
        "    if (size == 1) {\n"
        "        g_memByte[addr] = (byte)value;\n"
        "        return;\n"
        "    }\n"
        "\n"
        "    switch (addr % size) {\n"
        "    case 0:\n"
        "        if (size == 2)\n"
        "            g_memWord[addr / 2] = (word)value;\n"
        "        else\n"
        "            g_memDword[addr / 4] = value;\n"
        "        break;\n"
        "    case 1:\n"
        "        if (size == 2) {\n"
        "            g_memByte[addr] = value & 0xff;\n"
        "            g_memByte[addr + 1] = (byte)(value >> 8);\n"
        "        } else {\n"
        "            g_memDword[(addr - 1) / 4] = g_memByte[addr - 1] | (value << 8);\n"
        "            g_memByte[addr + 3] = value >> 24;\n"
        "        }\n"
        "        break;\n"
        "    case 2:\n"
        "        g_memWord[addr / 2] = value & 0xffff;\n"
        "        g_memWord[addr / 2 + 1] = value >> 16;\n"
        "        break;\n"
        "    case 3:\n"
        "        g_memByte[addr] = value & 0xff;\n"
        "        g_memDword[(addr + 1) / 4] = (g_memByte[addr + 4] << 24) | (value >> 8);\n"
        "        break;\n"
        "    }\n"
        "}\n"
        "\n"
        "char *offsetToPtr(dword offset)\n"
        "{\n"
        "    assert(!offset || offset == -1 || (offset & kExternalPointerMask ?\n"
        "        m_numPointers < kMaxPointers && (offset & ~kExternalPointerMask) < m_numPointers :\n"
        "        offset >= kMemStartOfs && offset + 4 <= kMemSize));\n"
        "\n"
        "    if (!offset)\n"
        "        return nullptr;\n"
        "\n"
        "    if (offset == -1)\n"
        "        return kSentinel;\n"
        "\n"
        "    return offset & kExternalPointerMask ? kPointerPool[(offset & ~kExternalPointerMask)] :\n"
        "        (char *)g_memByte + offset;\n"
        "}\n"
        "\n"
        "char *getExtraMemoryArea()\n"
        "{\n"
        "    return (char *)kExtendedMemStart;\n"
        "}\n"
        "\n"
        "static dword m_dynaMemMarker;\n"
        "\n"
        "SwosDataPointer<char> allocateMemory(size_t size)\n"
        "{\n"
        "    size = (size + 3) & ~3;\n"
        "    assert(m_dynaMemMarker + size <= kDynamicMemSize);\n"
        "\n"
        "    auto offset = kDynamicMemStart - g_memByte + m_dynaMemMarker;\n"
        "#ifdef DEBUG\n"
        "    memset(kDynamicMemStart + m_dynaMemMarker, 0xcc, size);\n"
        "#endif\n"
        "    m_dynaMemMarker += size;\n"
        "    return offset;\n"
        "}\n"
        "\n"
        "SwosDataPointer<char> allocateString(const char *str)\n"
        "{\n"
        "    assert(str);\n"
        "\n"
        "    if (isSwosPtr(str))\n"
        "        return ptrToOffset(str);\n"
        "\n"
        "    auto offset = kDynamicMemStart - g_memByte + m_dynaMemMarker;\n"
        "\n"
        "    while (kDynamicMemStart[m_dynaMemMarker++] = *str++)\n"
        "        ;\n"
        "\n"
        "    m_dynaMemMarker = (m_dynaMemMarker + 3) & ~3;\n"
        "    assert(m_dynaMemMarker <= kDynamicMemSize);\n"
        "\n"
        "    return offset;\n"
        "}\n"
        "\n"
        "SwosDataPointer<char> cacheString(const char *str)\n"
        "{\n"
        "    assert(str);\n"
        "\n"
        "    auto it = std::find_if(m_stringCache.begin(), m_stringCache.end(), [str](const auto& mapping) {\n"
        "        return mapping.first == str;\n"
        "    });\n"
        "\n"
        "    if (it != m_stringCache.end())\n"
        "        return it->second;\n"
        "\n"
        "    auto swosPtr = allocateString(str);\n"
        "    m_stringCache.emplace_back(str, swosPtr.getRaw());\n"
        "\n"
        "    return swosPtr;\n"
        "}\n"
        "\n"
        "void resetStringCache(dword mark)\n"
        "{\n"
        "    assert(mark <= m_stringCache.size());\n"
        "    m_stringCache.resize(mark);\n"
        "}\n"
        "\n"
        "void releaseMemory(dword mark)\n"
        "{\n"
        "    assert(mark <= m_dynaMemMarker && m_dynaMemMarker < kDynamicMemSize);\n"
        "#ifdef DEBUG\n"
        "    memset(kDynamicMemStart + mark, 0xdd, m_dynaMemMarker - mark);\n"
        "#endif\n"
        "    m_dynaMemMarker = mark;\n"
        "}\n"
        "\n"
        "dword getMemoryMark()\n"
        "{\n"
        "    return m_dynaMemMarker;\n"
        "}\n"
        "\n"
        "// register a pointer accessible from SWOS VM via pointer pool\n"
        "dword registerPointer(const void *ptr)\n"
        "{\n"
        "    assert(m_numPointers < kMaxPointers && (intptr_t)ptr != -1);\n"
        "\n"
        "    if (!ptr)\n"
        "        return -1;\n"
        "\n"
        "    for (size_t i = 0; i < m_numPointers; i++)\n"
        "        if (kPointerPool[i] == ptr)\n"
        "            return i | kExternalPointerMask;\n"
        "\n"
        "    kPointerPool[m_numPointers] = (char *)ptr;\n"
        "    return m_numPointers++ | kExternalPointerMask;\n"
        "}\n"
        "\n"
        "void releasePointers(dword mark)\n"
        "{\n"
        "    assert(mark < kMaxPointers && mark <= m_numPointers);\n"
        "    m_numPointers = mark;\n"
        "}\n"
        "\n"
        "dword getPointerPoolMark()\n"
        "{\n"
        "    return m_numPointers;\n"
        "}\n"
        "\n"
        "MemoryMark markAllMemory()\n"
        "{\n"
        "    auto memMark = getMemoryMark();\n"
        "    auto pointerMark = getPointerPoolMark();\n"
        "    auto procMark = getProcsMark();\n"
        "    dword cacheMark = m_stringCache.size();\n"
        "    return { memMark, pointerMark, procMark, cacheMark };\n"
        "}\n"
        "\n"
        "void releaseAllMemory(const MemoryMark& mark)\n"
        "{\n"
        "    releaseMemory(std::get<0>(mark));\n"
        "    releasePointers(std::get<1>(mark));\n"
        "    releaseProcs(std::get<2>(mark));\n"
        "    resetStringCache(std::get<3>(mark));\n"
        "}\n"
        "\n"
        "bool isExternalPointer(dword addr)\n"
        "{\n"
        "    return (addr & kExternalPointerMask) != 0;\n"
        "}\n\n";

    xfputs(kMemFunctions);
}

void VmFileWriter::outputDebugFunctions()
{
    const char kFunctions[] =
        "\n#ifdef DEBUG\n\n"
        "# ifndef debugBreak\n"
        "void debugBreak()\n"
        "{\n"
        "#  ifdef _MSC_VER\n"
        "__debugbreak();\n"
        "#  else\n"
        "#   error \"Debug break command needs to be defined\"\n"
        "#  endif\n"
        "}\n"
        "# endif\n"
        "\n"
        "void initSafeMemoryAreas()\n"
        "{\n"
        "    static uint8_t * const kSafeAreas[] = {\n"
        "        kExtendedMemStart - kSafeMemAreaSize,\n"
        "        kPointerPoolStart - kSafeMemAreaSize,\n"
        "        kDynamicMemStart - kSafeMemAreaSize,\n"
        "        kDynamicMemStart + kDynamicMemSize,\n"
        "    };\n"
        "    for (auto area : kSafeAreas)\n"
        "        for (size_t i = 0; i < kSafeMemAreaSize; i++)\n"
        "            area[i] = std::array<char, 3>{ 'z', 'k', 'z' } [i % 3];\n"
        "\n"
        "    memset(kDynamicMemStart, 0xee, kDynamicMemSize);\n"
        "}\n"
        "\n"
        "static void verifySafeMemoryArea(const byte *area, bool first = false)\n"
        "{\n"
        "    assert(!first || !area[0] && !area[1] && !area[2] && !area[3]);\n"
        "\n"
        "    std::array<char, 3> kSig{ 'z', 'k', 'z' };\n"
        "    for (int i = first ? 4 : 0; i < kSafeMemAreaSize; i++)\n"
        "        assert(area[i] == kSig[i % 3]);\n"
        "}\n"
        "\n"
        "void verifySafeMemoryAreas()\n"
        "{\n"
        "    verifySafeMemoryArea(g_memByte, true);\n"
        "    verifySafeMemoryArea(kMemStart + kBasicMemSize);\n"
        "    verifySafeMemoryArea(kExtendedMemStart + kExtendedMemSize);\n"
        "    verifySafeMemoryArea(kPointerPoolStart + kPointerPoolSize);\n"
        "    verifySafeMemoryArea(kDynamicMemStart + kDynamicMemSize);\n"
        "}\n"
        "\n"
        "#endif\n\n";

    xfputs(kFunctions);
}

size_t VmFileWriter::memArraySize() const
{
    auto size = m_dataBank.memoryByteSize();
    size = (size + 7) & ~7;
    return size;
}

FILE *VmFileWriter::outputFile(const char *filename, const char *contents, size_t size)
{
    const auto& filePath = Util::joinPaths(m_baseDir, filename);

    auto f = fopen(filePath.c_str(), "w");
    if (!f)
        return nullptr;

    auto result = fwrite(contents, size, 1, f) == 1;

    if (!result) {
        fclose(f);
        return nullptr;
    }

    return f;
}

void VmFileWriter::outputZeroMemoryRegion()
{
    xfputs("\n    ");
    outputComment("this is a special region for catching null pointer access");
    xfputs("\n    ");

    assert(DataBank::zeroRegionSize() > 4);

    // the original SWOS gets away by occasionally reading value 0 from address 0
    for (size_t i = 0; i < 4; i++)
        outputInt(0, 1);

    for (size_t i = 4; i < DataBank::zeroRegionSize(); i++)
        outputChar(std::array<char, 3>{ 'z', 'k', 'z' }[i % 3]);

    fseek(m_f, -1, SEEK_CUR);
}

void VmFileWriter::outputComment(const String& comment, bool skipInitialCommentMark /* = false */)
{
    auto trComm = trimComment(comment);

    while (!trComm.empty()) {
        int len = trComm.indexOf('\r');
        if (len < 0)
            len = trComm.indexOf('\n');
        if (len < 0)
            len = trComm.length();

        if (!skipInitialCommentMark)
            xfputs("// ");

        const auto& commentLine = trimComment(trComm.substr(0, len));
        xfputs(commentLine);

        skipInitialCommentMark = false;

        trComm = trimComment(trComm.substr(len));
        if (!trComm.empty())
            xfputs("\n    ");
        else
            break;
    }
}

String VmFileWriter::trimComment(const String& comment)
{
    size_t start = 0;
    while (start < comment.length() && Util::isSpace(comment[start]))
        start++;

    auto len = comment.length();
    while (len != 0 && Util::isSpace(comment[len - 1]))
        len--;

    return comment.substr(start, len - start);
}

void VmFileWriter::outputOriginalValue(const DataBank::Var& var, size_t offset)
{
    xfputs("// ");

    if (!var.name.empty()) {
        xfputs(var.name);
        xfputs(": ");
    }

    xfputs(var.originalValue);

    if (var.type == DataBank::kOffset && var.additionalOffset)
        xfprintf("+%Xh", var.additionalOffset);

    if (var.dup > 1)
        xfprintf(" dup(%d) ", var.dup * var.size);
    else
        xfputc(' ');

    if (var.alignment)
        xfprintf("[+%d alignment byte(s)] ", var.alignment);

    outputComment(var.comment, true);

    do {
        xfputc(' ');
    } while (m_pos < 60);

    char buf[256];
    _itoa(offset, buf, 10);

    xfputc('|');
    xfputs(buf);
    xfputc('|');
}

// this is explicitly little endian
void VmFileWriter::outputInt(size_t val, size_t size)
{
    while (size--) {
        hexByteToFile(val & 0xff);
        val >>= 8;
    }
}

void VmFileWriter::outputString(const DataBank::Var& var)
{
    for (size_t i = 1; i < var.stringValue.length() - 1; i++) {
        char c = var.stringValue[i];
        c >= 0 ? outputChar(c) : hexByteToFile(c);
    }
}

void VmFileWriter::outputChar(char c)
{
    xfputc('\'');

    if (c == '\\')
        xfputs("\\\\", true);
    else if (c == '\'')
        xfputs("\\'", true);
    else
        xfputc(c);

    xfputs("',", true);

    if (newLineNeeded())
        addNewLine();
    else
        xfputc(' ');
}

void VmFileWriter::outputOffset(const DataBank::Var& var)
{
    auto value = m_dataBank.getVarOffset(var.offsetVar);

    if (!var.structField.empty()) {
        auto structName = m_dataBank.structNameFromVar(var.offsetVar);
        const auto struc = m_structs.findStruct(structName->string());
        value += getStructFieldOffset(*struc, var.structField);
    }

    value += var.additionalOffset;

    outputInt(value, 4);
}

size_t VmFileWriter::getStructFieldOffset(const Struct& struc, const String& field) const
{
    size_t offset = 0;

    for (const auto& field : struc) {
        if (field.elementSize())
            offset += field.byteSize();
        else
            offset += m_structs.getStructSize(field.type());
    }

    return offset;
}

// Skip fputc calls here since this function is so heavily used
void VmFileWriter::hexByteToFile(uint8_t byte)
{
    char buf[256] = "0x";
    int len = 2;

    for (uint8_t c : { byte >> 4, byte & 0x0f }) {
        if (c < 10)
            buf[len++] = '0' + c;
        else
            buf[len++] = 'a' + c - 10;
    }

    buf[len++] = ',';

    if (m_pos + len >= kLineLimit) {
        memcpy(buf + len, "\n    ", 5);
        len += 5;
        m_pos = 4;
    } else {
        buf[len++] = ' ';
        m_pos += len;
    }

    xfwrite(buf, len);
}

bool VmFileWriter::newLineNeeded() const
{
    return m_pos >= kLineLimit;
}

void VmFileWriter::addNewLine()
{
    xfputs("\n    ", true);
}

void VmFileWriter::xfopen(const char *filename)
{
    m_filename = filename;

    const auto& filePath = Util::joinPaths(m_baseDir, filename);
    m_f = fopen(filePath.c_str(), "w");

    if (!m_f)
        fileError();
}

void VmFileWriter::xfclose()
{
    assert(m_f);

    if (m_f)
        fclose(m_f);
}

void VmFileWriter::xfwrite(const void *buf, size_t size)
{
    assert(m_f);

    if (fwrite(buf, size, 1, m_f) != 1)
        fileError();
}

void VmFileWriter::xfputs(const String& str)
{
    assert(m_f && !str.contains('\n'));

    if (!str.writeToFile(m_f))
        fileError();

    m_pos += str.length();
}

void VmFileWriter::xfputs(const char *str, bool updatePos /* = false */)
{
    assert(m_f);

    if (fputs(str, m_f) < 0)
        fileError();

    if (updatePos)
        updatePosition(str);
}

void VmFileWriter::xfputc(int c, bool updatePos /* = true */)
{
    assert(m_f);

    if (fputc(c, m_f) == EOF)
        fileError();

    if (updatePos)
        updatePosition(c);
}

void VmFileWriter::xfprintf(const char *format, ...)
{
    char buf[512];

    va_list argList;
    va_start(argList, format);
    vsnprintf(buf, sizeof(buf), format, argList);
    va_end(argList);

    xfputs(buf);
}

void VmFileWriter::fileError()
{
    throw OutputException("file I/O error", m_filename);
}

void VmFileWriter::updatePosition(const char *str)
{
    while (*str)
        updatePosition(*str++);
}

void VmFileWriter::updatePosition(char c)
{
    if (c == '\n')
        m_pos = 0;
    else
        m_pos++;
}
