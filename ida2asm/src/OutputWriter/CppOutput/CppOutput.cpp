#include "VmFileWriter.h"
#include "TypeInfo.h"
#include "OutputException.h"
#include "CppOutput.h"

constexpr auto kDefsFilename = "defs.h";
constexpr int kInProcLabelsCapacity = 38'000;

CppOutput::CppOutput(const char *path, int index, int extraMemorySize, bool disableOptimizations, const SymbolFileParser& symFileParser,
    const StructStream& structs, const DefinesMap& defines, const References& references, const OutputItemStream& outputItems,
    const DataBank& dataBank)
:
    OutputWriter(path, symFileParser, structs, defines, references, outputItems), m_index(index),
    m_extendedMemorySize(extraMemorySize), m_dataBank(dataBank),
    m_irConverter(disableOptimizations, structs, defines, references, m_dataBank), m_inProcLabels(kInProcLabelsCapacity),
    m_x86Writer(this, m_dataBank, symFileParser, m_inProcLabels)
{
}

void CppOutput::setCImportSymbols(const StringSet *syms)
{
    m_cImportSymbols = syms;
}

void CppOutput::setCExportSymbols(const StringList *syms)
{
    m_cExportSymbols = syms;
}

bool CppOutput::output(OutputFlags flags, CToken *)
{
    // we'll need a bigger output buffer to accommodate large number of C++ statements per line
    int size = 4 * (m_structs.size() + m_defines.size() + m_outputItems.size());

    if (!openOutputFile(flags, size))
        return false;

    if (!flags)
        return true;

    bool result = true;

    try {
        out("// " kAutoGeneratedWarningText, Util::kDoubleNewLine);

        bool isDefineFile = flags & (kStructs | kDefines) && !(flags & kFullDisasembly);
        if (isDefineFile) {
            VmFileWriter vmFileWriter(getOutputBaseDir(), m_extendedMemorySize, m_symFileParser, m_dataBank, m_structs);
            vmFileWriter.outputVmFiles();
            out("#pragma once", Util::kDoubleNewLine);
        } else {
            out("#include \"", VmFileWriter::kHeaderFilename, '"', Util::kNewLine);
            out("#include \"", kDefsFilename, '"', Util::kDoubleNewLine);
            out("#ifdef _MSC_VER", Util::kNewLine);
            out("# pragma warning(disable: 4309 4146 4333 4805 4102)", Util::kNewLine);
            out("#endif", Util::kDoubleNewLine);
            out("using namespace SwosVM;", Util::kDoubleNewLine);
        }

        if ((flags & kExterns) && !outputExterns())
            result = false;

        // we'll make everything public, so no need to output publics explicitly as in assembly
        // no need to output structs since they are handled specially (as offsets)

        if (flags & kDefines)
            outputDefines();

        if (flags & kDisassembly)
            outputCodeAndData();

        if (!save())
            result = false;

        closeOutputFile();
    } catch (const OutputException& e) {
        if (e.file())
            m_error += "in file: "s + e.file() + ", ";
        m_error += e.what();
        result = false;
    }

    return result;
}

const char *CppOutput::getDefsFilename() const
{
    return kDefsFilename;
}

void CppOutput::outputStructs()
{
    if (!m_structs.empty())
        out("#pragma pack(push, 1)", Util::kNewLine);

    for (auto& struc : m_structs)
        outputStruct(struc);

    if (!m_structs.empty())
        out("#pragma pack(pop)", Util::kNewLine);
}

void CppOutput::outputStruct(Struct& struc)
{
    outputComment(struc.leadingComments(), false);
    out(struc.isUnion() ? "union " : "struct ", struc.name(), Util::kNewLine, '{', Util::kNewLine);

    char anonBuf[32];
    int anonCounter = 0;

    for (const auto& field : struc) {
        if (!field.type().empty()) {
            out(kIndent, field.type(), ' ');
        } else {
            auto sizeSpecifier = getTypeInfo(field.elementSize()).unsignedType;
            out(kIndent, sizeSpecifier, ' ');
        }

        if (!field.name().empty()) {
            out(field.name());
        } else {
            sprintf(anonBuf, "%02d", anonCounter++);
            out(anonBuf);
        }

        if (!field.dup().empty())
            out('[', field.dup(), ']');

        out(';', Util::kNewLine);
    }

    out("};", Util::kNewLine);
    out("typedef ", struc.isUnion() ? "union " : "struct ", struc.name(), ' ', struc.name(), ';', Util::kNewLine);
}

bool CppOutput::outputExterns()
{
    if (m_references.externs().empty())
        return true;

    bool result = true;

    for (const auto& [name, refType, customType] : m_references.externs()) {
        assert(name.length() && name.data());

        switch (refType) {
        case References::kByte:
        case References::kWord:
        case References::kDword:
        case References::kQWord:
        case References::kTbyte:
        case References::kUser:
            break;

        case References::kNear:
        case References::kProc:
            out("extern void ", name, "();", Util::kNewLine);
            break;

        default:
            if (!m_error.empty())
                m_error += '\n';
            m_error += "undefined reference found: " + name.string();
            result = false;
            break;
        }
    }

    return result;
}

void CppOutput::outputDefines()
{
    for (auto it : m_defines) {
        auto def = it.cargo;

        outputComment(def->leadingComments(), false);
        out("#define ", def->name(), " ");

        if (def->isInverted())
            out('~');

        if (def->value().endsWith('h'))
            out("0x", def->value().withoutLast());
        else
            out(def->value());

        outputComment(def->comment());
    }
}

void CppOutput::outputCodeAndData()
{
    runFirstPass();

    const auto& instructions = m_irConverter.instructions();
    for (auto it = instructions.begin(); it != instructions.end(); ++it) {
        auto isLastItem = it + 1 == instructions.end();

        if (it->deleted)
            continue;

        switch (it->type) {
        case OutputItem::kInstruction:
            if (!m_insideProc || (!isLastItem && isFinalRetn(it)))
                continue;

            assert(it->instruction);
            outputInstruction(*it);
            break;
        case OutputItem::kProc:
            outputProcStart(*it);
            break;
        case OutputItem::kEndProc:
            outputEndProc(*it);
            break;
        case OutputItem::kLabel:
            if (isLastItem || (it + 2) == instructions.end() || !isFinalRetn(it + 1))
                outputLabel(*it);
            break;
        case OutputItem::kStackVariable:
            outputStackVariable(*it);
            break;
            // ignore everything else and hope it doesn't blow up
        }
    }

    if (m_insideProc)
        out('}', Util::kNewLine);
}

// Since assembler might reference labels without declaring them first, we'll simply forward declare all the data.
// Also divide labels into global (outside a proc) and local (inside a proc).
void CppOutput::runFirstPass()
{
    bool inProc = false;

    out(Util::kNewLine, "// first pass forward declarations", Util::kNewLine);

    for (const auto& item : m_outputItems) {
        switch (item.type()) {
        case OutputItem::kProc:
            {
                auto proc = item.getItem<Proc>();
                out("void ", proc->name(), "();", Util::kNewLine);
                inProc = true;
                m_irConverter.convertProc(&item, m_outputItems.end());
            }
            break;
        case OutputItem::kEndProc:
            inProc = false;
            break;
        case OutputItem::kLabel:
            if (inProc) {
                auto label = item.getItem<Label>();
                if (!label->isLocal())
                    m_inProcLabels.add(label->name());
            }
            break;
        }
    }

    out(Util::kNewLine);

    m_inProcLabels.seal();

    m_irConverter.optimizeFlags();
}

void CppOutput::outputInstruction(const InstructionNode& node)
{
    auto instruction = node.instruction;
    assert(node.type == OutputItem::kInstruction && instruction && m_insideProc);

    out(kIndent);

    auto initialOutputPtr = getOutputPtr();

    m_x86Writer.outputInstruction(node);

    bool hadOutput = getOutputPtr() != initialOutputPtr;
    if (hadOutput) {
        if (lastOutputChar() != '}' && lastOutputChar() != ';' && *initialOutputPtr != '#')
            out(';');

        outputOriginalInstructionComment(instruction, initialOutputPtr - sizeof(kIndent));

        if (instruction->isBranch() && instruction->type() != Token::T_CALL)
            out(Util::kNewLine);
    } else {
        removeOutputChar(kTabSize);
    }
}

void CppOutput::outputProcStart(const InstructionNode& node)
{
    assert(node.type == OutputItem::kProc);

    if (m_insideProc)
        out('}', Util::kDoubleNewLine);

    m_insideProc = true;

    const auto& leadingComments = node.leadingComments.trimmed();
    outputComment(leadingComments);

    if (leadingComments)
        out("//", Util::kNewLine);

    out("void ", node.label, "()", Util::kNewLine, '{', Util::kNewLine);

    if (node.needsStartLabel)
        out(kStartLabel, ":;", Util::kNewLine);
}

void CppOutput::outputEndProc(const InstructionNode& node)
{
    assert(m_insideProc);

    m_insideProc = false;

    if (outputLength() >= Util::kDoubleNewLine.size()) {
        auto testStart = getOutputPtr() - Util::kDoubleNewLine.size();
        if (!memcmp(testStart, Util::kDoubleNewLine.data(), Util::kDoubleNewLine.size()))
            removeOutputChar(Util::kNewLine.size());
    }

    if (node.label) {
        out(Util::kNewLine, kIndent);
        m_x86Writer.outputFunctionCall(node.label);
        out(';', Util::kNewLine);
    }

    out('}', Util::kDoubleNewLine);
}

void CppOutput::outputLabel(const InstructionNode& node)
{
    assert(node.type == OutputItem::kLabel);

    if (node.label == "return")
        return;

    if (m_insideProc) {
        if (!isLastLineEmpty())
            out(Util::kNewLine);

        outputLabel(node.label);
        out(":;");
    } else {
        out("// ", node.label);
    }

    out(Util::kNewLine);
}

void CppOutput::outputLabel(const String& label)
{
    if (label.startsWith("@@"))
        out("l_", label.substr(2));
    else
        out(label);
}

void CppOutput::outputStackVariable(const InstructionNode& node)
{
    assert(node.type == OutputItem::kStackVariable);
    out(kIndent, node.stackVarSize, ' ', node.label, " = 0;", Util::kNewLine);
}

bool CppOutput::isFinalRetn(InstructionsIterator it)
{
    assert(it->type == OutputItem::kInstruction);

    auto nextType = (it + 1)->type;

    return it->instruction->type() == Token::T_RETN &&
        (nextType == OutputItem::kEndProc || nextType == OutputItem::kProc || nextType == OutputItem::kDirective);
}

bool CppOutput::isLastLineEmpty() const
{
    auto doubleNewLineLen = Util::kDoubleNewLine.size();
    if (outputLength() < doubleNewLineLen)
        return false;

    return !memcmp(getOutputPtr() - doubleNewLineLen, Util::kDoubleNewLine.data(), Util::kDoubleNewLine.size());
}

void CppOutput::outputOriginalInstructionComment(const Instruction *instruction, const char *start)
{
    addCommentPadding(start);

    auto prefixSpace = !instruction->prefix().empty() ? " " : "";
    out("// ", instruction->prefix(), prefixSpace, instruction->instructionText());
    if (instruction->hasOperands())
        out(' ');

    for (size_t i = 0; i < instruction->numOperands(); i++) {
        const auto& operands = instruction->operands();
        const auto& operand = operands[i];
        const String *prev = nullptr;
        bool prevIsId = false;

        for (const auto& it : operand) {
            auto first = it.text().first();
            if (prev && Util::isId(prev->last()) && !prevIsId && (first == '@' || first == '[' || Util::isId(first)))
                out(' ');

            out(it.text());

            prev = &it.text();
            prevIsId = it.type() == Token::T_ID;
        }

        if (lastOutputChar() == ' ')
            removeOutputChar(1);

        if (i != instruction->numOperands() - 1)
            out(", ");
    }

    out(Util::kNewLine);
}

void CppOutput::addCommentPadding(const char *start)
{
    constexpr int kCommentOffset = 44;

    auto lineLength = getLineLength(start);
    int fillLength = kCommentOffset - lineLength;

    // always output at least one space between semi-colon and comment
    do {
        out(' ');
    } while (--fillLength > 0);
}

size_t CppOutput::getLineLength(const char *start)
{
    auto end = getOutputPtr();

    for (auto p = end - 1; p >= start; p--) {
        if (*p == '\n') {
            start = p + 1;
            break;
        }
    }

    return end - start;
}

void CppOutput::outputComment(const String& comment, bool endWithNewLine /* = true */)
{
    for (size_t i = 0; i < comment.length(); i++) {
        if (comment[i] == ';')
            out("//");
        else
            out(comment[i]);
    }

    if (endWithNewLine)
        out(Util::kNewLine);
}
